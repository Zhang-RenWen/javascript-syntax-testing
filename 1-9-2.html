<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="./public/favicon.ico" />
    <meta http-equiv="cache-control" content="no-cache" />
    <title></title>
    <link rel="stylesheet" href=" https://necolas.github.io/normalize.css/8.0.1/normalize.css" />
    <link rel="stylesheet" href="./hightlight/default.min.css" />
    <link rel="stylesheet" href="./css/main.css" />
    <link rel="stylesheet" href="./css/copybutton.css" />
    <link rel="stylesheet" href="./css/hightlight.css" />
    <script src="./hightlight/hightlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BEVZJDBC7Z"></script>
    <script src="./js/gtag.js"></script>
  </head>

  <body>
    <header>
      <nav>
        <h1>
          <span id="toggle-menu"></span>
          <a href="index.html"></a>
        </h1>
      </nav>
    </header>
    <main>
      <aside>
        <nav></nav>
      </aside>
      <article>
        <h2 id="1-9-2">1-9-2 演算法設計</h2>
        <h3>Linear Search 線性搜尋</h3>
        <p>實作思路：</p>
        <p>
          土法煉鋼從頭到尾一個一個搜尋一集合中的目標元素，直到找到目標元素停止或是搜索到最後一個元素仍然沒有匹配的元素結做結束。
        </p>

        <pre><code class="language-js">
function linearSearch(array, targetElement) {
  for (let index = 0;index &lt; array.length;index++) {
    if (targetElement === array[index]) {
      return index;
    }
  }
  return -1;
}
        </code></pre>
        <table>
          <thead>
            <tr>
              <th>複雜度</th>
              <th>Big O值</th>
              <th>說明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <th>最差時間複雜度</th>
              <td>O(n)</td>
              <td>直到走訪到最後一個元素才找到或該集合不包含此元素</td>
            </tr>
            <tr>
              <th>最佳時間複雜度</th>
              <td>O(1)</td>
              <td>第一個走訪到的元素就是目標元素。</td>
            </tr>
            <tr>
              <th>平均時間複雜度</th>
              <td>O(n)</td>
              <td></td>
            </tr>
          </tbody>
        </table>
        <h3>Binary Search 二分搜尋演算法</h3>
        <p>實作思路：</p>
        <p>
          假設有一個從小到大排序過的集合，設定集合中間的索引為基準，將集合分成兩半，另外再列出集合索引的最大值及最小值。
        </p>
        <p>如果這個數字大於中間值的元素表示目標在集合右側，反之則在左側。</p>
        <p>
          如果在右側就將最小值由中間值代換，反之則將中間值代換為最大值，代換完成再另外找中間的索引繼續下一輪動作。
        </p>
        <p>效率會比 Linear Search 來得好，只不過使用條件必須是在有排序的集合上。</p>
        <pre><code class="language-js">

function binarySearch(arr, n) {
  let min = 0;
  let max = arr.length - 1;
  let step = 0;

  while (min &lt;= max) {
    step++;
    let middle = Math.floor((max + min) / 2);
    if (n > arr[middle]) {
      min = middle + 1;
    } else if (n &lt; arr[middle]) {
      max = middle - 1;
    } else if (n === arr[middle]) {
      console.log("Found number " + n + " at position " + middle);
      console.log("Found it after " + step + " steps.");
      return middle;
    }
  }

  console.log("Cannot find number " + n);
  return -1;
}
        </code></pre>
        <table>
          <thead>
            <tr>
              <th>複雜度</th>
              <th>Big O值</th>
              <th>說明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <th>最差時間複雜度</th>
              <td>O(log n)</td>
              <td>直到走訪到最後一個元素才找到或該集合不包含此元素</td>
            </tr>
            <tr>
              <th>最佳時間複雜度</th>
              <td>O(1)</td>
              <td>元素正好在集合的正中間的索引上。</td>
            </tr>
            <tr>
              <th>平均時間複雜度</th>
              <td>O(log n)</td>
              <td></td>
            </tr>
          </tbody>
        </table>
        <h3>設計概念1 Counter</h3>
        <p>尋找兩集合中共相似之處可以使用的概念。</p>
        <p>案例1-尋找共同元素</p>
        <pre><code class="language-js">
const array1 = [1,3,5,6,7,8]
const array2 = [1,4,5,9,7,8,10]
function intersection(array1,array2){
  let result = []
  let array3 = array1.concat(array2)
  let counter = {}

  for(let i = 0; i &lt; array3.length; i++){
    if(!counter[array3[i]] ){
      counter[array3[i]] = 1
    }else{
      counter[array3[i]]++
    }
  }

  for(key in counter){
    if(counter[key]===2){
      result.push(key)
    }
  }

  return result
},       
        </code></pre>
        <p>案例2-尋找2個字串中，不管排列組合，比較是否使用相同的字母。</p>
        <pre><code class="language-js"> 
function sameFrequency(str1,str2){
  let array1 = str1.split('')
  let array2 = str2.split('')
  if(array1.length != array2.length)false

  let counter1 = {}
  let counter2 = {}
  let result = true

  array1.forEach(letter){
    if(!counter1[letter]){
      counter1[letter] = 1
    }else{
      counter1[letter]++
    }
  }
  array2.forEach(letter){
    if(!counter2[letter]){
      counter2[letter] = 1
    }else{
      counter2[letter]++
    }
  }
  for(letter in counter1){
    if(!counter2[letter])false
    if( counter1[letter]!==counter2[letter]){
      result = false
    }
  }
  return result
}

sameFrequency('abbc','aabc') // false
sameFrequency('abba','abab') // true
sameFrequency('aasdebasdf','adfeebed') // false

        </code></pre>
        <h3>設計概念2 Pointer</h3>
        <p>直接看案例：</p>
        <p>
          現在有一個需求，寫出一個方法，從集合中找出所有兩個為一對的數字,每一對數字的平均為選定的目標數字。
        </p>
        <p>
          像這樣
          <code>averagePair([-11,0,1,2,3,9,14,17,21],1.5)</code>
          回傳
          <code>[[-11,14],[0,3],[1,2]]</code>
        </p>
        <p>實作思路：將陣列由小到大排序後，由陣列的第一個和最後一個數字開始操作。</p>
        <p>
          (-11+21)/2 = 5 >
          1.5。結果不成對，接著從最後一個數字往回找，也就是17，然後再運算一次。(-11+17)/2 = 3 >
          1.5。結果還是不成對，接著找到 14。 (-11+14)/2 = 1.5 = 1.5。找到一組後將 [-11
          ,14]挑出來繼續找尋。 (0+9)/2 = 4.5 > 1.5 ..... 依此類推。
        </p>
        <pre><code class="language-js"> 
function averagePair(array,target){
  let result =[]
  let pointer1 = 0
  let pointer2 = array.length -1

  for(var i=0; i &lt; array.length-1; i++){
    if(pointer2-pointer1&gt;0){// 避免重複
      const element1 = array[pointer1]
      const element2 = array[pointer2]
      if((element1+element2)/2!==target){ 
        pointer2--
      }else{
        result.push([element1,element2])
        pointer1++
        pointer2--
      }
    } 
  }
  return result
}


        </code></pre>
        <pre><code class="language-js"> </code></pre>
      </article>
    </main>
  </body>
  <script type="module" src="./js/main.js"></script>
</html>
