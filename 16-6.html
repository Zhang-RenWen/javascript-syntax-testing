<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="./public/favicon.ico" />
    <meta http-equiv="cache-control" content="no-cache" />
    <title></title>
    <link rel="stylesheet" href=" https://necolas.github.io/normalize.css/8.0.1/normalize.css" />
    <link rel="stylesheet" href="./hightlight/default.min.css" />
    <link rel="stylesheet" href="./css/main.css" />
    <link rel="stylesheet" href="./css/copybutton.css" />
    <link rel="stylesheet" href="./css/hightlight.css" />
    <script src="./hightlight/hightlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BEVZJDBC7Z"></script>
    <script src="./js/gtag.js"></script>
  </head>

  <body>
    <header>
      <nav>
        <h1>
          <span id="toggle-menu"></span>
          <a href="index.html"></a>
        </h1>
      </nav>
    </header>
    <main>
      <aside>
        <nav></nav>
      </aside>
      <article>
        <h2 id="16-6">16-6 Private class features</h2>
        <p>
          Class æ¬„ä½é è¨­æ˜¯å…¬æœ‰çš„ã€‚æˆ‘å€‘å¯ä»¥å¦å¤–é€éå‰ç¶´
          <code>#</code>
          è®“ Class æˆå“¡è½‰æ›ç‚ºç§æœ‰ã€‚ ç§æœ‰å±¬æ€§ Class çš„å°è£æœƒè¢« Javascript è‡ªå‹•å¼·åˆ¶åŸ·è¡Œã€‚
        </p>
        <h3>èªæ³•</h3>
        <pre><code class="language-js">
class ClassWithPrivate {
  #privateField;
  #privateFieldWithInitializer = 42;

  #privateMethod() {
    // â€¦
  }

  static #privateStaticField;
  static #privateStaticFieldWithInitializer = 42;

  static #privateStaticMethod() {
    // â€¦
  }
}
        </code></pre>
        <p>ä»¥ä¸‹åˆ—èˆ‰é¡å¤–çš„èªæ³•é™åˆ¶</p>
        <ul>
          <li>
            æ‰€æœ‰ç§æœ‰é¡åˆ¥ä¸­çš„è­˜åˆ¥ç¬¦è™Ÿéƒ½å¿…é ˆæ˜¯å”¯ä¸€çš„ã€‚éœæ…‹å±¬æ€§å’Œå¯¦ä¾‹å±¬æ€§å…±ç”¨å‘½åæ¬„ä½ï¼Œå”¯ä¸€çš„ä¾‹å¤–æ˜¯å®šç¾©ä¸€çµ„
            getter/setterã€‚
          </li>
          <li>
            ç§æœ‰çš„è­˜åˆ¥ç¬¦è™Ÿä¸èƒ½ç‚º
            <code>#constructor</code>
          </li>
        </ul>
        <p>å¤§éƒ¨åˆ† Class ç‰¹æ€§éƒ½æœ‰å°ˆå±¬çš„ç§æœ‰å‹æ…‹ï¼š</p>
        <ul>
          <li>Private fields</li>
          <li>Private methods</li>
          <li>Private static fields</li>
          <li>Private static methods</li>
          <li>Private getters</li>
          <li>Private setters</li>
          <li>Private static getters</li>
          <li>Private static setters</li>
        </ul>
        <p>ç„¶è€Œåœ¨ Javascript è£¡ ï¼Œå»ºæ§‹å­æ˜¯ç„¡æ³•ç§æœ‰åŒ–çš„ã€‚</p>
        <p>
          ä»¥ä¸‹æœ‰ä¸€äº›éŒ¯èª¤ç¤ºç¯„ï¼š ä¸€å€‹æ˜¯ä½¿ç”¨
          <code>delete</code>
          ï¼Œå¦å€‹ä¸€å€‹å‰‡æ˜¯åœ¨ Class ç§æœ‰æ¬„ä½å¤–å»æ”¹è®Šç§æœ‰ç‰¹æ€§ã€‚
        </p>
        <pre><code class="language-js error-code">
class ClassWithPrivateField {
  #privateField;

  constructor() {;
    delete this.#privateField; // Syntax error
    this.#undeclaredField = 42; // Syntax error
  }
}

const instance = new ClassWithPrivateField();
instance.#privateField; // Syntax error
        </code></pre>
        <p>
          JavaScript ä½œç‚ºä¸€ç¨®å‹•æ…‹èªè¨€ï¼Œç”±æ–¼ç‰¹æ®Šçš„ Hash
          æ¨™è­˜ç¬¦èªæ³•è€Œèƒ½å¤ åŸ·è¡Œé€™ç¨®ç·¨è­¯æ™‚æª¢æŸ¥ï¼Œä½¿å…¶åœ¨èªæ³•ç´šåˆ¥ä¸Šä¸åŒæ–¼æ™®é€šå±¬æ€§ã€‚
        </p>
        <div class="notecard">
          <p>
            <strong>æ³¨æ„ï¼š</strong>
            åœ¨ Chrome æ§åˆ¶å°ä¸­é‹è¡Œçš„ä»£ç¢¼å¯ä»¥è¨ªå•é¡å¤–éƒ¨çš„ç§æœ‰å±¬æ€§ã€‚é€™æ˜¯å° JavaScript èªæ³•é™åˆ¶çš„åƒ…é™
            DevTools çš„æ”¾å¯¬ã€‚
          </p>
        </div>
        <p>
          å¦‚æœå¾ä¸å…·æœ‰è©²å±¬æ€§çš„ç‰©ä»¶è¨ªå•ç§æœ‰å±¬æ€§ï¼Œå‰‡æœƒæ‹‹å‡º TypeError è€Œä¸æ˜¯ undefined
          åƒæ™®é€šå±¬æ€§é‚£æ¨£å›å‚³ã€‚
        </p>
        <pre><code class="language-js error-code">
class C {
  #x;

  static getX(obj) {
    return obj.#x;
  }
}

console.log(C.getX(new C())); // undefined
console.log(C.getX({})); // TypeError: Cannot read private member #x from an object whose class did not declare it
        </code></pre>
        <p>
          ä¸Šé¢æ¡ˆä¾‹ä¹Ÿæ¼”ç¤ºäº†ï¼Œåœ¨ç”Ÿæˆå¯¦é«”ä»¥å¾Œæˆ‘å€‘ä»ç„¶å¯ä»¥é€ééœæ…‹æ–¹æ³•è¨ªå•ç§æœ‰å±¬æ€§ã€‚è‹¥ç›´æ¥æ“ä½œ class
          å‰‡ç„¡æ³•è¨ªå•ã€‚
        </p>
        <p>
          æˆ‘å€‘ä¹Ÿå¯ä»¥é€é
          <code>in</code>
          é‹ç®—å­å»æª¢æŸ¥æ˜¯å¦æœ‰ç§æœ‰å±¬æ€§ã€‚ æœ‰çš„è©±å›å‚³
          <code>true</code>
          ï¼Œå¦å‰‡
          <code>false</code>
          ã€‚
        </p>
        <pre><code class="language-js correct-code">
class C {
  #x;
  constructor(x) {
    this.#x = x;
  }
  static getX(obj) {
    if (#x in obj) return obj.#x;

    return "obj must be an instance of C";
  }
}
console.log(C.getX(new C("foo"))); // "foo"
console.log(C.getX(new C(0.196))); // 0.196
console.log(C.getX(new C(new Date()))); // the current date and time
console.log(C.getX({})); // "obj must be an instance of C"
        </code></pre>
        <p>
          è«‹æ³¨æ„ï¼Œç§æœ‰åç¨±æŒ‰æ¨è«–å§‹çµ‚æ˜¯é å…ˆè²æ˜ä¸”ä¸å¯åˆªé™¤çš„ï¼šå¦‚æœæ‚¨ç™¼ç¾ä¸€å€‹ç‰©ä»¶æ“æœ‰ç•¶å‰é¡çš„ä¸€å€‹ç§æœ‰å±¬æ€§ï¼ˆç„¡è«–æ˜¯ä¾†è‡ª
          <code>try...catch</code>
          é‚„æ˜¯
          <code>in</code>
          checkï¼‰ï¼Œå®ƒå¿…é ˆæ“æœ‰æ‰€æœ‰å…¶ä»–ç§äººå±¬æ€§ã€‚æ“æœ‰é¡çš„ç§æœ‰å±¬æ€§çš„ç‰©ä»¶é€šå¸¸æ„å‘³è‘—å®ƒæ˜¯ç”±è©²é¡ç”Ÿæˆçš„ï¼ˆå„˜ç®¡ä¸¦éç¸½æ˜¯å¦‚æ­¤ï¼‰ã€‚
        </p>
        <p>
          ç§æœ‰å±¬æ€§ä¸æ˜¯åŸå‹ç¹¼æ‰¿æ¨¡å‹çš„ä¸€éƒ¨åˆ†ï¼Œå› ç‚ºå®ƒå€‘åªèƒ½åœ¨ç•¶å‰é¡çš„ä¸»é«”å…§è¨ªå•ï¼Œä¸¦ä¸”ä¸èƒ½ç”±å­é¡ç¹¼æ‰¿ã€‚ä¸åŒé¡ä¸­å…·æœ‰ç›¸åŒåç¨±çš„ç§æœ‰å±¬æ€§å®Œå…¨ä¸åŒï¼Œä¸¦ä¸”ä¸èƒ½äº’æ“ä½œã€‚å°‡å®ƒå€‘è¦–ç‚ºé™„åŠ åˆ°æ¯å€‹å¯¦ä¾‹çš„å¤–éƒ¨å…ƒæ•¸æ“šï¼Œç”±é¡ç®¡ç†ã€‚å› æ­¤ï¼Œ
          <code>Object.freeze()</code>
          å’Œ
          <code>Object.seal()</code>
          å°ç§æœ‰å±¬æ€§æ²’æœ‰å½±éŸ¿ã€‚
        </p>
        <h3>ç¯„ä¾‹</h3>
        <h4>Private fields ç§æœ‰æ¬„ä½</h4>
        <p>
          ç§æœ‰æ¬„ä½åŒ…å« ç§æœ‰å¯¦ä¾‹æ¬„ä½(private instance fields) ä»¥åŠ ç§æœ‰éœæ…‹æ¬„ä½(private static
          fields)ã€‚ Class å…§éƒ¨å®£å‘Šç§æœ‰æ¬„ä½çš„æ‰èƒ½è¢«è¨ªå•ã€‚
        </p>
        <h4>Private instance fields ç§æœ‰å¯¦ä¾‹æ¬„ä½</h4>
        <p>å°±åƒä»–å€‘çš„ç›¸å°æ‡‰çš„å…¬æœ‰æ¬„ä½ç§æœ‰éœæ…‹æ¬„ä½ï¼š</p>
        <ul>
          <li>
            åœ¨å»ºæ§‹å­åŸ·è¡Œå‰å°±è¢«åŠ å…¥æˆ–è€…åœ¨å­é¡åˆ¥ä¸­çš„
            <code>super</code>
            è¢«è§¸ç™¼å¾Œç«‹å³åŸ·è¡Œã€‚
          </li>
          <li>åªèƒ½åœ¨ class å¯¦ä¾‹è£¡é¢è¢«è¨ªå•</li>
        </ul>
        <pre><code class="language-js">
class ClassWithPrivateField {
  #privateField;

  constructor() {
    this.#privateField = 42;
  }
}

class Subclass extends ClassWithPrivateField {
  #subPrivateField;

  constructor() {
    super();
    this.#subPrivateField = 23;
  }
}

new Subclass(); // In some dev tools, it shows Subclass {#privateField: 42, #subPrivateField: 23}
        </code></pre>
        <div class="notecard">
          <p>
            <strong>æ³¨æ„ï¼š</strong>
            ä¾†è‡ª
            <code>#ClassWithPrivateField</code>
            çš„
            <code>#privateField</code>
            åŸºæœ¬ class å°
            <code>#ClassWithPrivateField</code>
            ä¾†èªªæ˜¯ç§æœ‰çš„ï¼Œ ä¸èƒ½å¾è¡ç”Ÿçš„å­é¡è¨ªå•ã€‚
          </p>
        </div>
        <h3>Returning overriding object å›å‚³è¦†å¯«ç‰©ä»¶</h3>
        <p>
          ä¸€å€‹é¡åˆ¥çš„å»ºæ§‹å­å¯ä»¥å›å‚³ä¸åŒçš„ç‰©ä»¶ï¼Œé€™å€‹ç‰©ä»¶æœƒè¢«è¡ç”Ÿçš„ class å»ºæ§‹å­ç•¶ä½œæ–°çš„
          <code>this</code>
          ã€‚é€™å€‹è¡ç”Ÿçš„ class
          å¯èƒ½æœƒå®šç¾©ç§æœ‰çš„æ¬„ä½åœ¨å›å‚³çš„ç‰©ä»¶ä¸Šã€‚é€™æ„å‘³è‘—è¡ç”Ÿç‰©ä»¶å¯èƒ½æ¨™è¨˜ç§æœ‰æ¬„ä½çµ¦ä¸ç›¸é—œçš„ç‰©ä»¶ä¸Šã€‚
        </p>
        <pre><code class="language-js">
class Stamper extends class {
  // A base class whose constructor returns the object it's given
  constructor(obj) {
    return obj;
  }
} {
  // This declaration will "stamp" the private field onto the object
  // returned by the base class constructor
  #stamp = 42;
  static getStamp(obj) {
    return obj.#stamp;
  }
}

const obj = {};
new Stamper(obj);
// `Stamper` calls `Base`, which returns `obj`, so `obj` is
// now the `this` value. `Stamper` then defines `#stamp` on `obj`

console.log(obj); // In some dev tools, it shows {#stamp: 42}
console.log(Stamper.getStamp(obj)); // 42
console.log(obj instanceof Stamper); // false

// You cannot stamp private properties twice
new Stamper(obj); // Error: Initializing an object twice is an error with private fields

        </code></pre>
        <div class="notecard warning">
          <p>
            è­¦å‘Šï¼šåœ¨æ“ä½œä¸Šå¯èƒ½æœƒæœ‰ä¸€äº›è®“äººå›°æƒ‘ã€‚ä¸€èˆ¬ä¾†èªªä½ æœƒå»ºè­°é¿å…å¾å»ºæ§‹å­å›å‚³ä»»ä½•æ±è¥¿ï¼Œå°¤å…¶æ˜¯è·Ÿ
            <code>this</code>
            ç„¡é—œçš„æ±è¥¿ã€‚
          </p>
        </div>
        <h3>Private static fields ç§æœ‰éœæ…‹æ¬„ä½</h3>
        <p>é¡ä¼¼ç›¸å°æ‡‰çš„å…¬æœ‰æ¬„ä½ï¼Œç§æœ‰éœæ…‹æ¬„ä½æœ‰ä»¥ä¸‹ç‰¹æ€§ï¼š</p>
        <ul>
          <li>ç·¨è­¯éšæ®µè¢«åŠ å…¥è‡³æ§‹é€ å‡½å¼ä¸­</li>
          <li>åªèƒ½ç”±æœ¬èº«çš„ class è¨ªå•</li>
        </ul>
        <pre><code class="language-js">
class ClassWithPrivateStaticField {
  static #privateStaticField = 42;

  static publicStaticMethod() {
    return ClassWithPrivateStaticField.#privateStaticField;
  }
}

console.log(ClassWithPrivateStaticField.publicStaticMethod()); // 42
        </code></pre>
        <p>
          class éœæ…‹ç§æœ‰æ¬„ä½çš„é™åˆ¶ï¼šåªæœ‰å®šç¾©äº†éœæ…‹ç§æœ‰æ¬„ä½çš„ class èƒ½è¨ªå•åˆ°ã€‚ä½¿ç”¨
          <code>this</code>
          å¾ˆæœ‰å¯èƒ½å°è‡´éé æœŸéŒ¯èª¤ã€‚èˆ‰å€‹ä¾‹å­ï¼š
          <code>this</code>
          æŒ‡çš„æ˜¯
          <code>Subclass</code>
          ï¼Œ(ä¸æ˜¯
          <code>ClassWithPrivateStaticField</code>
          ) ç•¶æˆ‘å€‘å‘¼å«
          <code>Subclass.publicStaticMethod()</code>
          çš„æ™‚å€™æœƒé€ æˆ
          <code>TypeError</code>
          ã€‚
        </p>
        <pre><code class="language-js">
class ClassWithPrivateStaticField {
  static #privateStaticField = 42;

  static publicStaticMethod() {
    return this.#privateStaticField;
  }
}

class Subclass extends ClassWithPrivateStaticField {}

Subclass.publicStaticMethod(); // TypeError: Cannot read private member #privateStaticField from an object whose class did not declare it
        </code></pre>
        <p>
          å‘¼å«
          <code>super</code>
          ä¹Ÿæœƒæœ‰ç›¸åŒçš„å•é¡Œã€‚å› ç‚º
          <code>super</code>
          æ–¹æ³•ç„¡æ³•ä»¥
          <code>super</code>
          é¡åˆ¥ç•¶ä½œ
          <code>this</code>
          çš„æƒ…æ³è¢«å‘¼å«ã€‚
        </p>
        <pre><code class="language-js">
class ClassWithPrivateStaticField {
  static #privateStaticField = 42;

  static publicStaticMethod() {
    // When invoked through super, `this` still refers to Subclass
    return this.#privateStaticField;
  }
}

class Subclass extends ClassWithPrivateStaticField {
  static callSuperMethod() {
    return super.publicStaticMethod();
  }
}

Subclass.callSuperMethod(); // TypeError: Cannot read private member #privateStaticField from an object whose class did not declare it
        </code></pre>
        <p>
          å› æ­¤ä½ æœƒå»ºè­°ç›¡é‡é€é class åç¨±å»è¨ªå•éœæ…‹ç§æœ‰è®Šæ•¸è€Œä¸æ˜¯é€é
          <code>this</code>
          ã€‚æ‰€ä»¥ç¹¼æ‰¿ä¸æœƒæ‰“ç ´é€™å€‹æ–¹æ³•ã€‚
        </p>
        <h3>Private methods ç§æœ‰æ–¹æ³•</h3>
        <p>ç§æœ‰æ–¹æ³•åŒ…æ‹¬ç§æœ‰ç§æœ‰å¯¦ä¾‹æ–¹æ³•ä»¥åŠç§æœ‰éœæ…‹æ–¹æ³•ã€‚ç§æœ‰æ–¹æ³•åªèƒ½åœ¨é¡åˆ¥å®£å‘Šä¸­è¢«è¨ªå•</p>
        <h3>Private instance methods ç§æœ‰å¯¦ä¾‹æ–¹æ³•</h3>
        <p>èˆ‡ç›¸å°æ‡‰çš„å…¬æœ‰æ–¹æ³•ä¸åŒï¼Œç§æœ‰å¯¦ä¾‹æ–¹æ³•ï¼š</p>
        <ul>
          <li>åœ¨å¯¦ä¾‹æ¬„ä½è¢«æ›è¼‰ä¹‹å‰æœƒç«‹å³æ›è¼‰</li>
          <li>
            åƒ…é©ç”¨æ–¼è©²é¡çš„å¯¦ä¾‹ï¼Œä¸é©ç”¨æ–¼å…¶
            <code>.prototype</code>
            å±¬æ€§ã€‚
          </li>
        </ul>
        <pre><code class="language-js">
class ClassWithPrivateMethod {
  #privateMethod() {
    return 42;
  }

  publicMethod() {
    return this.#privateMethod();
  }
}

const instance = new ClassWithPrivateMethod();
console.log(instance.publicMethod()); // 42
        </code></pre>
        <p>
          ç§æœ‰å¯¦ä¾‹æ–¹æ³•å¯ä»¥æ˜¯ç”Ÿæˆå™¨ã€ç•°æ­¥æˆ–ç•°æ­¥ç”Ÿæˆå™¨å‡½æ•¸ã€‚ç§æœ‰
          <code>getter</code>
          å’Œ
          <code>setter</code>
          ä¹Ÿæ˜¯å¯èƒ½çš„ï¼Œä¸¦ä¸”éµå¾ªèˆ‡å…¶å°æ‡‰çš„å…¬å…±
          <code>getter</code>
          å’Œ
          <code>setter</code>
          ç›¸åŒçš„èªæ³•è¦æ±‚ã€‚
        </p>
        <pre><code class="language-js">
class ClassWithPrivateAccessor {
  #message;

  get #decoratedMessage() {
    return `ğŸ¬${this.#message}ğŸ›‘`;
  }
  set #decoratedMessage(msg) {
    this.#message = msg;
  }

  constructor() {
    this.#decoratedMessage = "hello world";
    console.log(this.#decoratedMessage);
  }
}

new ClassWithPrivateAccessor(); // ğŸ¬hello worldğŸ›‘
        </code></pre>
        <p>
          èˆ‡å…¬æœ‰æ–¹æ³•ä¸åŒï¼Œç§æœ‰æ–¹æ³•ç„¡æ³•é€šéå…¶é¡çš„
          <code>.prototype</code>
          å±¬æ€§è¨ªå•ã€‚
        </p>
        <pre><code class="language-js">
class C {
  #method() {}

  static getMethod(x) {
    return x.#method;
  }
}

console.log(C.getMethod(new C())); // [Function: #method]
console.log(C.getMethod(C.prototype)); // TypeError: Receiver must be an instance of class C
        </code></pre>
        <h3>Private static methods ç§æœ‰éœæ…‹æ–¹æ³•</h3>
        <p>èˆ‡å…¬å…±æ–¹æ³•ä¸€æ¨£ï¼Œç§æœ‰éœæ…‹æ–¹æ³•ï¼š</p>
        <ul>
          <li>åœ¨é¡åˆ¥ç·¨è­¯æ™‚è¢«æ·»åŠ åˆ°é¡åˆ¥çš„æ§‹é€ å‡½æ•¸ä¸­</li>
          <li>åƒ…é©ç”¨æ–¼é¡åˆ¥æœ¬èº«ã€‚</li>
        </ul>
        <pre><code class="language-js">
class ClassWithPrivateStaticMethod {
  static #privateStaticMethod() {
    return 42;
  }

  static publicStaticMethod() {
    return ClassWithPrivateStaticMethod.#privateStaticMethod();
  }
}

console.log(ClassWithPrivateStaticMethod.publicStaticMethod()); // 42
        </code></pre>
        <p>ç§æœ‰éœæ…‹æ–¹æ³•å¯ä»¥æ˜¯ç”Ÿæˆå™¨ã€ç•°æ­¥å’Œç•°æ­¥ç”Ÿæˆå™¨å‡½æ•¸ã€‚</p>
        <p>
          å‰é¢æåˆ°çš„ç§æœ‰éœæ…‹æ¬„ä½çš„ç›¸åŒé™åˆ¶ä¹Ÿé©ç”¨æ–¼ç§æœ‰éœæ…‹æ–¹æ³•ï¼Œä¸¦ä¸”é¡ä¼¼åœ°åœ¨ä½¿ç”¨å®ƒæ™‚å¯èƒ½æœƒå°è‡´æ„å¤–çš„è¡Œç‚ºã€‚åœ¨ä¸‹é¢çš„ç¯„ä¾‹ä¸­ï¼Œç•¶æˆ‘å€‘å˜—è©¦èª¿ç”¨
          <code>Subclass.publicStaticMethod()</code>
          æ™‚ï¼Œå®ƒå¼•ç”¨çš„æ˜¯
          <code>Subclass</code>
          é¡ï¼ˆè€Œä¸æ˜¯
          <code>ClassWithPrivateStaticMethod</code>
          é¡ï¼‰ï¼Œå› æ­¤æœƒå°è‡´
          <code>TypeError</code>
          ã€‚
        </p>
        <pre><code class="language-js">
class ClassWithPrivateStaticMethod {
  static #privateStaticMethod() {
    return 42;
  }

  static publicStaticMethod() {
    return this.#privateStaticMethod();
  }
}

class Subclass extends ClassWithPrivateStaticMethod {}

console.log(Subclass.publicStaticMethod()); // TypeError: Cannot read private member #privateStaticMethod from an object whose class did not declare it
        </code></pre>
        <h3>Simulating private constructors æ¨¡æ“¬ç§æœ‰å»ºæ§‹å­</h3>
        <p>
          è¨±å¤šå…¶ä»–èªè¨€éƒ½åŒ…å«å°‡æ§‹é€ å‡½æ•¸æ¨™è¨˜ç‚ºç§æœ‰çš„åŠŸèƒ½ï¼Œé€™å¯ä»¥é˜²æ­¢é¡åœ¨é¡æœ¬èº«ä¹‹å¤–å¯¦ä¾‹åŒ– -
          æ‚¨åªèƒ½ä½¿ç”¨å‰µå»ºå¯¦ä¾‹çš„éœæ…‹å·¥å» æ–¹æ³•ï¼Œæˆ–è€…æ ¹æœ¬ç„¡æ³•å‰µå»ºå¯¦ä¾‹ã€‚ JavaScript
          æ²’æœ‰æœ¬åœ°æ–¹æ³•ä¾†åŸ·è¡Œæ­¤æ“ä½œï¼Œä½†å¯ä»¥é€šéä½¿ç”¨ç§æœ‰éœæ…‹æ¨™èªŒä¾†å®Œæˆã€‚
        </p>
        <pre><code class="language-js">
class PrivateConstructor {
  static #isInternalConstructing = false;

  constructor() {
    if (!PrivateConstructor.#isInternalConstructing) {
      throw new TypeError("PrivateConstructor is not constructable");
    }
    PrivateConstructor.#isInternalConstructing = false;
    // More initialization logic
  }

  static create() {
    PrivateConstructor.#isInternalConstructing = true;
    const instance = new PrivateConstructor();
    return instance;
  }
}

new PrivateConstructor(); // TypeError: PrivateConstructor is not constructable
PrivateConstructor.create(); // PrivateConstructor {}
        </code></pre>
        <p>è³‡æ–™ä¾†æº:</p>
        <p>
          <a
            href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields"
          >
            https://developer.mozilla.org/.../Private_class_fields
          </a>
        </p>
      </article>
    </main>
  </body>
  <script type="module" src="./js/main.js"></script>
</html>
