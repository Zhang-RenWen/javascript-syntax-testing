<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="./public/favicon.ico" />
    <meta http-equiv="cache-control" content="no-cache" />
    <title></title>
    <link rel="stylesheet" href=" https://necolas.github.io/normalize.css/8.0.1/normalize.css" />
    <link rel="stylesheet" href="./hightlight/default.min.css" />
    <link rel="stylesheet" href="./css/main.css" />
    <link rel="stylesheet" href="./css/copybutton.css" />
    <link rel="stylesheet" href="./css/hightlight.css" />
    <script src="./hightlight/hightlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BEVZJDBC7Z"></script>
    <script src="./js/gtag.js"></script>
  </head>

  <body>
    <header>
      <nav>
        <h1>
          <span id="toggle-menu"></span>
          <a href="index.html"></a>
        </h1>
      </nav>
    </header>
    <main>
      <aside>
        <nav></nav>
      </aside>
      <article>
        <h2 id="1-18-5">1-18-5 網路通訊基礎-傳輸層安全性 TLS</h2>
        <p>
          SSL （Secure Sockets
          Layer，安全套接層）協定是網景公司（Netscape）最初設計用來啟動網頁上的電子商務傳輸安全性，而這項協定會運用加密技術來保護消費者的個人資料，並搭配驗證程序和完整性保證機制，來確保交易安全。為了達到這個目標，SSL
          協定被直接實作在 TCP
          的最上面，並且會使用著各種協定（HTTP、電子郵件、即時傳訊等等）的應用層（application
          layer）當中（如圖-1），如此即可在跨網路通訊情況下，以不做任何改變的方式提供通訊安全性。
        </p>
        <p>圖1: 傳輸層安全性（TLS）</p>
        <img src="./assets/image/1-18-5/1.jpg" alt="" />
        <p>
          當 SSL
          被正確使用時，第三方觀察者就只能夠推測出連線端點、加密類型，以及資料發送的頻繁程度和大約傳輸量，但是卻無法對實際的資料進行讀取或任何的修改作業。
        </p>
        <p>
          當 SSL 協定被 IETF 進行標準化的時候，就已經被更名為「TLS」（Transport Layer
          Security，傳輸層安全性）。許多地方都會交替使用 TLS 和 SSL
          名稱，但技術上，它們是不一樣的，因為它們個別所描述的是不一樣的協定版本。
        </p>
        <p>
          SSL 2.0 是最早被公開釋出的協定版本，不過它很快就因為被發現好幾個安全缺陷，而改由 SSL 3.0
          所取代。由於 SSL 協定的所有權是屬於 Netscape 公司，因此 IETF
          花了點功夫去對這個協定進行標準化，進而制訂出 RFC2246 一也就是所謂的 TLS
          1.0，而且也有效地升級到等同 SSL 3.0 的程度：
        </p>
        <p>
          這個協定與 SSL 3.0 之間的差異並不大，但很明顯地是要預先排除在 TLS 1.0 和 SSL
          3.0之間進行互換的情況。 —TLS 協定 RFC 2246
        </p>
        <p>
          自從 TLS 1.0 在 1999年一月發佈開始，IETF
          工作小組已經提出了另外兩個新版本，以解決找到的安全缺陷，並對協定的能力進行擴充一在 2006年4
          月釋出了 TLS 1.1，而 2008年8月 則釋出了 TLS1.2。內部的 SSL 3.0 實作部分以及後續的 TLS
          版本，其實都非常類似的，而儘管有很多希望使用者升級到新版本才能避免因安全漏洞而遭到攻擊的理由，但截至目前為止還是有許多客戶端都持續在使用
          SSL 3.0 和 TLS 1.0。
        </p>
        <p>
          TLS 被設計好是要在 TCP 之類的可靠傳輸協定上進行運作的。然而，它也有被改寫出能夠在 UDP
          之類的資料包協定上運作的版本。在 RFC 6347裡所定義的 DTLS（Datagram Transport Layer
          Security，資料包傳輸層安全性）協定，就是以 TLS
          協定為基礎所發展出來，而且能夠在保持資料包傳輸模式的情況下，提供類似的安全性。
        </p>
        <h3>加密、驗證與完整性</h3>
        <p>
          TLS
          協定被設計成會對使用這項協定的所有應用程式，提供「加密」（encryption）、「驗證」（authentication），和「資料完鳖性」（data
          integrity）等三項必要服務。技術上，你不一定會在每一種情況下，都需要用到這全部三種。你可能會決定去接受一份未經可靠性驗證處理的憑證，但是你應該要清楚瞭解其中的安全性風險，以及這樣做的後續影響。實際上，一個安全的網頁應用程式都將會運用到這全部的三項服務。
        </p>
        <ul>
          <li>
            <span>加密（Encryption）</span>
            <div>
              可用來把要從一台電腦發送至另一台的東西給弄亂，以致於無法直接看出原本內容的一種機制。
            </div>
          </li>
          <li>
            <span>驗證（Authentication）</span>
            <div>可用來對提供的識別資料進行有效性檢驗處理的一種機制。</div>
          </li>
          <li>
            <span>完整性（Integrity）</span>
            <div>可用來偵測出訊息被篡改或者被偽造情況的一種機制。</div>
          </li>
        </ul>
        <p>
          為了建立起一個加密安全資料通道，連線端就必須認可會被使用到的密碼組（ciphersuites），以及會被用來對資料進行加密處理的金鑰資料（key）。TLS
          協定會指定一個有明確定義的交握程序，來執行這項交換作業。這項交握的巧妙之處，以及 TLS
          可以實際運作起來的原因，就是在它使用了「公開金鑰加密」（public key
          cryptography）（也被稱為「非對稱金鑰加密」），而這樣的方式讓連線端在不需建立起相互間的任何預備知識的情況下，並且在未加密的通道上，即可去協定出一個共用的安全金鑰。
        </p>
        <p>
          在 TLS
          交握程序當中，協定也允許連線兩端都去對它們的識別資訊進行驗證。當運用在瀏覽器裡頭的時候，這項驗證機制可讓客戶端去對它所要求的伺服器（像是你的網路銀行）進行查證作業（verify），以確保該伺服器不是有人以造假伺服器名稱或
          IP
          位址的方式，所偽裝的目標主機。這項查證作業是建構在既定信任鏈的基礎之上。此外，伺服器還可以選擇性地對客戶端的識別資訊進行查證一比如說，公司的代理伺服器（proxy
          server）能夠對所有員工進行驗證，而每個人都可以擁有專屬自己，並由公司所簽署的唯一憑證。
        </p>
        <p>
          最後，在搭配加密和驗證機制的情況下，TLS 協定還可以提供自己的訊息框架（message
          framing）機制，並且搭配一個「訊息驗證代碼」（message authenticationcode,
          MAC）來對每個訊息進行簽署。MAC
          演算法是一種單向加密雜湊函數（一種有效的校驗和機制），而其中的金鑰則是由連線兩端去進行協定。每當有個TLS
          記錄被發送出去，MAC值就會被產生出來，並且被附加到那個訊息上，而接收者則能夠去計算，並查證被發送過來的MAC值，以確保訊息的完整性和真實性。
        </p>
        <p>
          結合道三項機制，就可以用來當作網頁上安全通訊的一項基礎功能。所有最新的網頁瀏覽器都能支援各種不同的密碼組，並且能夠對客戶端和伺服器端進行驗證，甚至針對每筆記錄，執行訊息完鳖性的查核作業。
        </p>
        <div class="border-block">
          <h3>代理伺服器、中介裝置、TLS，以及網站上的新協定</h3>
          <p>
            HTTP
            的可擴充性和成功，創造了網站上的各種代理伺服器（proxy）和中介裝置（intermediaries）的蓬勃發展的生態系統一這當中包括有：快取伺服器、安全閘道器、網頁快取裝置、內容過濾器，以及其他相關裝置。其中的某些裝置，我們是可以察覺到它們的存在（像是代理伺服器），但是其他的某些裝置，對於終端使用者來說，則完全無法察覺它們的存在。
          </p>
          <p>
            遺憾的是，這些伺服器的大幅成功與存在情況，對於試著要以任何可能方式來攏脫 HTTP
            協定的人來說，會有點小問題一某些代理伺服器（proxy server）可能只是在轉送 HTTP
            擴充資訊（extensions），或是它們無法進行解讀的替代線路格式而已，而其他的裝置則可能不明就裡，只會繼續盲目地套用它們的處理邏輯，以致於有些像安全裝置之類的設備，可能會在空無一物的地方，憑空地推斷出有惡意流量的存在狀况。
          </p>
          <p>
            換句話說，實際上，只要脫離「HTTP 是在通訊埠 80
            上」的明確定義，往往就會引導出不可靠的配置情況一有些客戶端是完全不會問題，但其他情況則可能會因為不可預知的行為反應而導致失敗一比如說，同一個客戶端可能會隨著它在不同網路之間的遷移情況，而看到不同的連線行為反應。
          </p>
          <p>
            由於會有這類行為，所以新的協定和 WebSocket、SPDY，以及其他 HTTP
            擴充功能，通常就得藉著建立一個 HTTPS
            通道的方式，來繞過中介代理伺服器，以便提供一套可靠的配置模型，而當中的加密通道會對來自於中介裝置的資料進行模糊處理。這樣雖然可以解決中介裝置的問題，但是對於要提供驗證、快取、安全性掃瞄等等的有用服務，而不是要當作單純中介者的裝置來說，這樣的作法就會有問題。
          </p>
          <p>
            這就是為何大多數 WebSocket 指南都會跟你說，要使用 HTTPS
            來進行行動裝置的資料傳遞處理的原因了。由於隨著時間演進，仲介裝置都已升級到有辦法辨識出新的協定，因此除非你的傅輸議程真的需要用到
            TLS 所提供的加密、驗證和完整性，否則對於 HTTPS 配置的需求將會變得比較沒那麼重要了。
          </p>
        </div>
        <h3>TLS 交握程序</h3>
        <p>
          在客戶端和伺服器可以開始透過 TLS
          去進行應用程式的交換處理之前，加密通道就得先完成協商作業一客戶端和伺服器都必須認可 TLS
          協定的版本、選擇密碼組，並在必要之時，對憑證進行檢驗。然而，這裡頭的每一個步驟都得在客戶端和伺服器之間進行新的封包往返處理（如圖-2），而這些都會增加整個
          TLS 連線的啟動延遲時間。
        </p>
        <p>圖2: TLS 交握協定</p>
        <img src="./assets/image/1-18-5/2.jpg" alt="" />
        <p>
          圖2 就和之前的 TCP 連線一樣，是以表1 為例，來假設紐約和倫敦之間的單向光纖延遲時間都是 28
          毫秒。
        </p>

        <ul>
          <li>
            <span>0 ms</span>
            <div>
              TLS
              是運作在一個可靠的傳輸方式（TCP）上，而這意味著我們必須先花上一個完𤨣的往返傳輸作業，來完成
              TCP 三向交握程序。
            </div>
          </li>
          <li>
            <span>56 ms</span>
            <div>
              有了 TCP 連線之後，客戶端會以純文字的形式來發送一些規格資訊，像是目前要使用的TLS
              協定版本、有支援的密碼組清單，還有其他可能會用到的TLS選項。
            </div>
          </li>
          <li>
            <span>84 ms</span>
            <div>
              伺服器會針對更進一步的通訊作業，挑出要使用的 TLS
              版本，並從客戶端所提供的清單當中，選用一組密碼組，再將它附加到自己的憑證上，然後把回應訊息發送給客戶端。或者，伺服器也可以對客戶端發出請求來索取憑證和
              TLS 擴充功能的其他參數。
            </div>
          </li>
          <li>
            <span>112 ms</span>
            <div>
              假設兩邊都能夠協商出一種共同版本和密碼，而客戶端也同意由伺服器所提供的憑證的話，接著客戶端就會產生一個新的對稱金鑰（symmetric
              key），並將它與伺服器的公開金鑰（public
              key）進行加密處理，最後再知會伺服器進一步地轉換到加密通訊作業的通訊上。截至目前為止，除了剛剛以伺服器的公開金鑰所加密過的對稱金鑰以外，所有的資料都是以明文的形式進行交換處理。
            </div>
          </li>
          <li>
            <span>140 ms</span>
            <div>
              伺服器會對客戶端所發送而來的對稱金鑰進行解密處理，並搭配 MAC
              的檢驗作業來檢查訊息的完整性，然後再把加密過的「完成」訊息回傳給客戶端。
            </div>
          </li>
          <li>
            <span>168 ms</span>
            <div>
              客戶端會搭配之前所產生的對稱金鑰進行解密，並檢驗
              MAC，然後如果正確無誤的話，整個傳輸通道就會被建立起來，而應用程式資料就可以被進行傳送處理了。
            </div>
          </li>
        </ul>
        <p>
          新 的TLS
          連線需要經過兩次往返傳輸作業，才能完成一次「完整交握程序」。然而，要是採用一種名為「簡略交握程序」（abbieviated
          handshake）的方式的話，就只需要經過一次的往返傳輸作業。
        </p>
        <p>
          安全 TLS
          的協商作業是一項挺複雜的程序，而且很容易出錯。所幸，剛剛所描述的那些所有處理工作，都會由伺服器和瀏覽器來幫我們完成，而我們所必須做的，就是去進行憑證的提供和設定處理。
        </p>
        <p>
          總之，雖然我們的網頁應用程式不一定都要去驅動先前的交換作業，但是它還是得讓每個 TLS
          連線，在 TCP
          交握程序上執行兩個額外的往返傳輸作業才行一因此，在應用程式資料可以被進行交換處理之前，得先等上好一段時間！要是沒有小心控管好的話，透過
          TLS 來進行應用程式資料的傳輸作業，還可能會再增加上百，甚至是上千毫秒的網路延遲時間。
        </p>
        <div class="border-block">
          <h3>公開和對稱金鑰的加密處理效能</h3>
          <p>
            「公開金鑰加密作業」（public-key cryptography）就只有在 TLS
            通道的議程設定程序當中被使用到。伺服器會把它的公開金鑰提供給客戶端，接著客戶端會搭配伺服器的公開金鑰來進行加密，而產生出對稱金鑰，然後再把加密過的對稱金鑰（symmetric
            key）回傳給伺服器。最後，伺服器就能夠透過它的私用金鑰（private
            key）來對對稱金鑰進行解密處理。
          </p>
          <p>
            使用著客戶端所產生出來的共用密鑰的「對稱密鑰加密作業」（symmetric key
            cryptography），會在客戶端與伺服器之間的所有後續通訊作業中都會被使用到。
            在大多數情況下，這樣做將可以提升效能一而相對來說，公開金鑰加密作業則會耗費較高的計算成本。若要瞭解這當中的差異，你可以在自己的電腦當中安裝
            OpenSSL，並進行以下這些測試：
          </p>
          <ul>
            <li>$> openssl speed rsa</li>
            <li>$> openssl speed aes</li>
          </ul>
          <p>
            請注意一下，在這兩項測試之間的單位是無法直接比較的：RSA
            測試會針對不同的金鑰大小，來提供一份每秒會進行多少次運算作業的總表，而 AES
            效能則是以每秒處理多少個位元組的單位來表示。不過，應該很容易就可以看出 RSA 運算（完整
            TLS 交握程序）的數值，而在所建議的 1,024 或 2,048 位元的金鑰長度時，可能就是瓶頸了。
          </p>
          <p>
            確切的效能數值有可能會因為使用的硬體、核心數量、TLS
            版本，伺服器設定，以及其他因素，而有明顯差異。總之，千萬別任意相信市調或某份過時的效能測試結果！只有在自己的機器上實際進行效能測試，才是最真實的。
          </p>
        </div>

        <p>圖:</p>
        <img src="./assets/image/1-18-5/.jpg" alt="" />
        <div class="border-block"></div>
      </article>
    </main>
  </body>
  <script type="module" src="./js/main.js"></script>
</html>
