<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>JavaScript-syntax-learning</title>
  <link rel="stylesheet" href="./hightlight/default.min.css" />
  <link rel="stylesheet" href=" https://necolas.github.io/normalize.css/8.0.1/normalize.css" />
  <link rel="stylesheet" href="./css/main.css" />
  <script src="./hightlight/hightlight.min.js"></script>
  <script>
    hljs.highlightAll();
  </script>
</head>

<body>
  <nav>
    <h1>現代 Javascript 實務應用</h1>
  </nav>
  <main>
    <aside></aside>
    <section>
      <h2>4-4 非同步函式</h2>
      <h3 id="4-4-1">
        4-4-1 非同步函式的意義
      </h3>
      <P>
        假設我們有一段如下方的程式碼，其中fetch 請求被包裹於
        getRandomArticle 函式中；當請求成功時，所回傳的 Promise 物件為已實現並附帶 JSON 格式的 body 主體資訊；若失敗，則依循標準的 fetch
        已拒絕機制處理‧
      </P>
      <pre><code class="language-js">
function getRandomArticle(){
  return fetch('/articles/random', {
    headers: new Headers({
      Accept:'application/json'
    })
  })
  .then(res =&gt; res.json())
}
        </code></pre>
      <p>
        下一段程式碼則說明 getRandomArticle 函式基本的運用方式。我們會建立一個 Promise 物件鏈結，它會擷取文章的JSON 物件，並傳遞至非同步的 renderView 的畫面描繪函式，在完成後會產生一個
        HTML 頁面，接著再以該 HTML 頁面取得我們的頁面内容。為了避免無法捕捉到的錯誤，我們利用 console.error 可將所有發生的拒絕原因輸出。
      </p>
      <pre><code class="language-js">
getRandomArticle()
.then(model =&gt; renderView(model))
.then(html =&gt; setPageContents(html))
.then(() =&gt; console.log('Successfully changed page!'))
.catch(err =&gt; console.error (err))
        </code></pre>
      <p>
        Promise 物件鏈結是很難除錯的：流程控制的錯誤原因很難追溯，且撰寫以 Promise 物件為基礎的程式碼流程，閱讀起來是比撰寫更加不易，常會導致後續維護上的困難。
      </p>
      <p>
        如果是單使用單純 JavaScript 回呼函式,我們的程式碼內容會較具重複性，就如接下來的範例一樣。同時,也落入回呼困境:在非同步程式流程中的每一個步驟都再加入一層縮排,使得程式碼更難閱讀理解。
      </p>
      <pre><code class="language-js">
getRandomArticle( (err, model) =&gt;{
  if (err) {
    return console.error(err)
  }
  renderView(model, (err, html) =&gt; {
    if (err) {
      return console.error(err)
    }
    setPageContents (html, err =&gt; {
      if (err) {
        return console.error(err)
      }
      console.log('Successfully changed page!')
    })
  })
})
        </code></pre>
      <p>當然,以函式庫可以解決回呼困境,和錯誤處理的重複性·函式庫的使用可受惠於標準化回呼函式的優點,如 async 非同步,將第一個引數保留給錯誤使用。若使用它的 waterfall 方法,我們的程式又會變得更簡潔一些。</p>
      <pre><code class="language-js">
async.waterfall([
  getRandomArticle,
  renderView,
  setPageContents
  ], (err, html) =&gt;{
    if (err){
      return console.error(err)
    }
    console.log('Successfully changed page! ')
  }
)
        </code></pre>
      <p>
        我們再看一個類似的範例，但這次我們將使用產生器。下面的範例是 getRandomArticle 的重製版，此處我們使用產生器以改變 getRandomArticle 的使用方式。
      </p>
      <pre><code class="language-js">
function getRandomArticle(gen) {
  const g = gen()
  fetch('/articles/random', {
  headers: new Headers({
      Accept: 'application/json'
    })
  })
  .then(res =&gt; res.json())
  .then(json =&gt; g.next(json))
  .catch(err =&gt; g.throw(err))
}
        </code></pre>
      <p>以下的程式碼展示如何透過 yield 運算式，自 getRandomArticle 函式中擷取 json
        結果值。即使看起來像是同步進行，現在其實已加入了產生器函式。當我們希望加入更多步驟時，必須大幅更動getRandomArticle ，才能夠以 yield 出產期望的結果值；並需調整產生器內容，以使用最新的結果序列。</p>
      <pre><code class="language-js">
getRandomArticle( function* printRandomArticle() {
  const json = yield
  // render view
})
        </code></pre>
      <p>
        在此案例中，使用產生器可能不是達到我們期望的結果最直覺的方式：只是把複雜性搬移到其他地方而已，而我們也受限於 Promise 的使用。
      </p>
      <p>
        除了將不直覺的語法加入其中，迭代器的程式碼也將與使用中的產生器函式高度地結合；這表示當產生器程式碼中加入了 yield 運算式，迭代器的程式碼也必須一併調整。
      </p>
      <p>
        另一個較佳的方案是使用 async 函式。
      </p>
      <h3 id="4-4-2">
        4-4-2 使用 async/await
      </h3>
      <p>非同步函式可讓我們採用以 Promise 物件為基礎的實作，同時也受益於外觀看似同步的產生器。這種方法的一個巨大優點是，你將完全不需要變更原始的 getRandomArticle 函式：只要它回傳一個可被等候的
        Promise 物件。</p>
      <p>
        請注意，await 只能夠在非同步函式中使用，函式須以關鍵宇 async 標示。非同步函式的運作類似於產生器，可在本文中暫停執行直到 Promise 物件已確認狀態為止。若被等待的運算式並不是一個 Promise
        物件，則會被轉換型態為 Promise 物件。
      </p>
      <p>
        下面的程式碼使用我們最初的 getRandomArticle 函式，它使用 Promise 物件進行運作。接著它會透過一個名稱為renderView的非同步函式，傳回 HTML 結果更新頁面内容。請注意我們如何使用
        try/catch 在被等候的 Promise 物件中進行錯誤理,就如我們在同步程式操作一樣。
      </p>
      <pre><code class="language-js">
async function read() {
  try {
    const model = await getRandomArticle()
    const html = await renderView(model)
    await setPageContents(html)
    console.log('Successfully changed page!')
  } catch (err) {
    console. error (err)
  }
 }

read()
      </code></pre>
      <p>
        非同步函式均會回傅一個 Promise 物件。萬一發生末捕捉的錯誤時，則回傅已拒絕的 Promise 物件。此外，回傳的物件也可解析為回傳值。非同步函式允許我們將這兩種回傳型態與一般以 Promise
        物件為基礎的方法繼續搭配使用。下面範例說明如何將這兩種回傳型態結合運用。
      </p>
      <pre><code class="language-js">

      </code></pre>
      <pre><code class="language-js">
async function read() {
  const model = await getRandomArticle()
  const html = await renderView(model)
  await setPageContents(html)
  return 'Successfully changed page!'
}

read()
.then(message =&gt; console.log (message))
.catch(err =&gt; console.error (err))
      </code></pre>
      <p>
        若要護 read 函式更具再利用性，我們可以將 html 結果回傳，並允許使用者利用Promise 或其他的非同步函式進行後續處理。這樣你的 read 函式功能就可以專注於擷取頁面的 HTML 內容。
      </p>
      <pre><code class="language-js">
async function read() {
  cost model = await getRandomArticle()
  const html = await renderView(model)
  return html
}
      </code></pre>
      <p>
        在下面範例中 ，我們運用單純的 Promise 物件將 HTML 輸出。
      </p>
      <pre><code class="language-js">
read().then(html =&gt; console.log(html))
      </code></pre>
      <p>
        使用非同步函式對後續的處理也較不會那麼困難。在下方的程式碼中，我們建立了一個 write 函式，作為後續的應用處理。
      </p>
      <pre><code class="language-js">
async function write() {
  const html = await read()
  console.log(html)
}
      </code></pre>
      <p>
        那同時進行的非同步流程會如何呢?
      </p>
      <pre><code class="language-js">

      </code></pre>
      <h3 id="4-4-3">
        4-4-3 同時發生的非同步流程
      </h3>
      <p>
        在非同步程式碼的流程中，經常會同時地執行兩個或多個工作。利用非同步函式可以很容易的撰寫非同步程式，同時在程式上也將它們以一次進行一個非同步操作的方式撰寫。一個函式若有多個 await 運算式在其中，則在每一個await
        運算執行時會暫停一次，直到 Promise 狀態確認，恢復運作並至下一個 await 運算之前一這和我們所看到的產生器與 yield 運算式的案例類似。
      </p>
      <pre><code class="language-js">
async function concurrent (){
  const p1 = new Promise(resolve=&gt;
  setTimeout (resolve, 500,'fast')
)
  const p2 = new Promise (resolve=&gt;
  setTimeout (resolve, 200,'faster')
)
  const p3 = new Promise (resolve =&gt;
  setTimeout (resolve, 100,'fastest')
)
  const r1 = await p1 // 運作會暫停，直到 p1 己確認狀態
  const r2 = await p2
  const r3 = await p3
}
      </code></pre>
      <p>
        我們可以使用 Promise.all 修正此問題，透過建立一個我們可以 await 的 Promise 物件。和用此方式，我們的程式碼運作會暫停，直到清單中的每一個 Promise 物件都確認狀態後，它們就同時地完成解析。
      </p>
      <p>
        下面的範例示範如何利用 await 等待三個不同的 Promise 物件並同時完成解析。假定 await 暫停了你的 async 函式，且 await Promise.all 運算式最終會將解析結果置於 results
        結果陣列中。你可以利用解構賦值的方式將每一個結果值自陣列中取出。
      </p>
      <pre><code class="language-js">
async function concurrent (){
  const p1 = new Promise(resolve=&gt;
    setTimeout (resolve, 500,'fast')
  )
  const p2 = new Promise(resolve=&gt;
    setTimeout (resolve, 200,'faster')
  )
  const p3 = new Promise(resolve=&gt;
    setTimeout (resolve, 100,'fastest')
  )
  const [r1, r2, r3] = await Promise.all([p1, p2, p3])
  console.log(r1, r2, r3)
  //'fast','faster','fastest'
}
      </code></pre>
      <p>
        我們可以使用 Promise.race 自較早實現的 Promise 物件中取得結果。
      </p>
      <pre><code class="language-js">
async function race (){
  const p1 = new Promise(resolve=&gt;
    setTimeout (resolve, 500,'fast')
  )
  const p2 = new Promise(resolve=&gt;
    setTimeout (resolve, 200,'faster')
  )
  const p3 = new Promise(resolve=&gt;
    setTimeout (resolve, 100,'fastest')
  )
  const result = await Promise.race([p1, p2, p3])
  console.log(result)
  // 'fastest'
}
              </code></pre>
      <h3 id="4-4-4">
        4-4-4 錯誤處理
      </h3>
      <p>
        在 async 函式中，錯誤會被無聲地抑制下來，就像是在內部的普通 Promise 物件；因為非同步函式被包裹於一個 Promise 物件中。若在你的非同步函式主體中發生了未被捕提的例外，或執行一個 await
        運算式暫停運作的期間，將會拒絕 async 函式所回傳的 Promise 物件。
      </p>
      <p>也就是說，除非我們在 await 運算式的周圍加入 try/catch 區塊，才能夠處理鐠誤。對非同步函式被包裹的程式部分，所發生的錯誤就會以 try/catch 的機制進行處理。</p>
      <p>自然地，這可以視為是一項特點：某些無法用非同步回呼函式處理的事項，和某些以 Promise 物件可以處理的事項，你就可以使用 try/catch的錯誤處理機制。在這些情境下，非同步函式與產生器類似，可以運用
        try/catch 錯誤處理機制，因為中止函式執行的動作可將非同步流程轉變為表面上同步的程式流程。</p>
      <p>
        除此之外,藉由在函式回傳的 Promise 物件加入 .catch 子句,你可以自 async 函式外捕捉到發生的錯誤。結合 try/catch
        子句是一個具有彈性的方法,但也會導致混淆並最終造成未捕捉處理的錯誤，除非所撰寫出來的非同步函式內容,在該環境下以 try/catch 的運作和 Promise 包裹的角度審視,均可讓人輕鬆理解。
      </p>
      <pre><code class="language-js">
        read()
        .then(html=&gt; console.log(html))
        .catch(err =&gt; console.error (err))
      </code></pre>
      <p>如你所見，還有一些方法可以捕捉到例外錯誤，並接著進行處理、記錄、或卸載。</p>
      <h3 id="4-4-5">
        4-4-5 了解非同步函式的內部運作
      </h3>
      <pre><code class="language-js">

      </code></pre>
      <div class="border-block"></div>
    </section>
  </main>
</body>
<script src="./menu.js"></script>

</html>