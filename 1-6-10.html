<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="./public/favicon.ico" />
    <meta http-equiv="cache-control" content="no-cache" />
    <title></title>
    <link rel="stylesheet" href=" https://necolas.github.io/normalize.css/8.0.1/normalize.css" />
    <link rel="stylesheet" href="./hightlight/default.min.css" />
    <link rel="stylesheet" href="./css/main.css" />
    <link rel="stylesheet" href="./css/copybutton.css" />
    <link rel="stylesheet" href="./css/hightlight.css" />
    <script src="./hightlight/hightlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BEVZJDBC7Z"></script>
    <script src="./js/gtag.js"></script>
  </head>

  <body>
    <header>
      <nav>
        <h1>
          <span id="toggle-menu"></span>
          <a href="index.html"></a>
        </h1>
      </nav>
    </header>
    <main>
      <aside>
        <nav></nav>
      </aside>
      <article>
        <h2 id="1-6-10">1-6-10 標準化工具管理團隊</h2>
        <p>
          不管是團隊的擴張還是業務的發展，都會導致專案程式量出現爆炸式增長。
          為了防止「野蠻生長」現象，需要有一個良好的技術選型和成熟的架構做支撐，也需要團隊中每一個開發者都能用心維護專案。在此方向上，會使用一些標準工具。
        </p>
        <h4>prettier</h4>
        <p>
          首先從 prettier 說起，所以顧名思義，prettier
          這個工具能夠美化程式，或說格式化、標準化程式，使其更加工整。它一般不會檢查程式的寶際寫法，而是在「可讀性」上做文章，目前支援包含
          JavasScript、JSX、Angular、Vue、Flow 、TypeScript、CSS （Less 、SCSS）、JSON
          等多種語言，以及資料交換格式、語法標準擴充。歸納一下，它能夠將原始程式風格移除，並取代為團隊統一設定的程式風格。幾乎所有團隊都在使用這款工具。
        </p>
        <ul>
          <li>建置並統一程式風格。</li>
          <li>幫助團隊新成員快速融入團隊。</li>
          <li>開發者可以完全聚焦業務開發，不必在程式整理上花費過多心思。</li>
          <li>方便低成本靈活連線，並快速發揮作用。</li>
          <li>清理並標準已有程式。</li>
          <li>減少潛在 bug。</li>
          <li>有豐富強大的社區支援。</li>
        </ul>
        <p>下面來看一個簡單的 demo。首先，透過下面的指令建立一個專案。</p>

        <pre><code class="language-bash">
mkdir prettier-demo && cd prettier-demo
        </code></pre>
        <p>然後，透過下面的指令進行專案初始化。</p>
        <pre><code class="language-bash">
yarn init -y
        </code></pre>
        <p>接著安裝依賴，指令如下。</p>
        <pre><code class="language-bash">
yarn add prettier --dev --exact
        </code></pre>
        <p>在 package.json 檔案中加入 scripts，如下所示。</p>
        <pre><code class="language-js">
{
  "name": "prettier-demo",
  "version": "1.0.0",
  "scripts": {
    "prettier":"prettier --write src/index.js"
  }
}
        </code></pre>
        <p>
          prettier --write src/index.js 的意思是執行 prettier，並對 src/index.js
          檔案進行處理，--write 標識告訴 prettier 要把格式化後的內容儲存到目前檔案中。
        </p>
        <p>在 ./sre 目錄中新增 index.js 檔案，並在檔案中輸入一些格式缺失的程式，如下所示。</p>
        <pre><code class="language-js">
let person = {
  name: "Yoda",
  designation: 'Jedi Master '
}

function trainJedi (jediWarrion) {
  if (jediWarrion.name === 'Yoda') {
    console.log('No need! already trained')
  }
  console.log (`Training ${jediWarrion.name} complete` )
}

trainJedi(person)
trainJedi({name:'Adeel', designation: 'padawan'})
        </code></pre>
        <p>同時，在 root 檔案中建立 prettier.config.js 檔案，並在檔案中增加 prettier 規則。</p>
        <pre><code class="language-js">
module.exports = {
  printWidth: 100, 
  singleQuote: true, 
  trailingComma: 'all', 
  bracketSpacing: true, 
  jsxBracketSameLine: false, 
  tabWidth: 2,
  semi: true,
}
        </code></pre>
        <p>
          prettier
          會讀取這些規則，並按照以上規則設定、美化程式。對於這些規則，透過其名稱便能了解其大概意思，更多內容可去官網檢視。
        </p>
        <p>執行以下指令，程式就會被自動格式化了。</p>
        <pre><code class="language-bash">
yarn prettier
        </code></pre>
        <p>
          當然：prettier 也可以與編輯器結合，在開發者儲存程式後立即對程式進行美化：也可以將 prettier
          整合到 CI 環節或 git pre-commit 階段。舉例來說，使用 pretty-quick
          在程式提交時對程式進行美化，指令如下。
        </p>
        <pre><code class="language-bash">
yarn add prettier pretty-quick husky--dev
        </code></pre>
        <p>同時，需要要在 package.json 中設定以下內容。</p>
        <pre><code class="language-js">
{
  "husky": {
    "hooks": {
      "pre-commit": "pretty-quick —-staged"
    }
  }
}
        </code></pre>
        <p>
          在 husky 中定義 pre-commit 階段，並只對 staged 的檔案進行格式化。 這裡使用了官方推薦的
          pretty-quick 來實現 pre-commit 階段的美化，這只是其中一種實現方式，還可以透過 lint-staged
          來實現。在下面介紹 ESLint 和 husky 時會講到 lint-staged。透過 demo 可以看出，prettier
          確實很靈活，且自動化程度很高，連入專案也十分方便。
        </p>
        <h4>ESLint</h4>
        <p>
          下面來看一下以 ESLint 為代表的 linter。多數程式語言都有
          linter，它們常常被整合在編譯階段，完成 coding linting。code linting
          表示基於靜態分析程式原理找出程式反模式的過程。
        </p>
        <p>
          對 JavaScript 這種動態、鬆類型的語言來說，開發者在撰寫程式時更容易犯錯。由於 JavaScript
          不具備先天編譯流程，因此常常會在執行時期曝露錯誤，而 linter，尤其是最具代表性的
          ESLint，可以使開發者在執行前就發現程式錯誤或不合理的寫法。
        </p>
        <p>ESLint 中最重要的幾點哲學思想如下。</p>
        <ul>
          <li>所有規則都外掛程式化。</li>
          <li>所有規則都可抽換（隨時開關）。</li>
          <li>所有設計都透明化。</li>
          <li>使用 espree 進行 JavaScript 解析。</li>
          <li>使用 AST 分析語法。</li>
        </ul>
        <p>下面來簡單設定一個 ESLint 規則，步驟如下。</p>
        <p>首先，初始化專案，指令如下。</p>
        <pre><code class="language-bash">
yarn init -y
        </code></pre>
        <p>然後，透過以下指令安裝依賴。</p>
        <pre><code class="language-bash">
yarn add eslint --dev
        </code></pre>
        <p>接著，執行以下指令。</p>
        <pre><code class="language-bash">
npx eslint --init
        </code></pre>
        <p>之後就可以使用 eslint 對任意檔案進行處理了，指令如下。</p>
        <pre><code class="language-bash">
eslint XXX.js
        </code></pre>
        <p>當然，想要順利執行 eslint，還需要安裝應用規則外掛程式。</p>
        <p>那麼，如何宣告並使用規則呢？在根目錄中開啟 .eslintrc 設定檔，在該檔案中加入以下內容。</p>
        <pre><code class="language-js">
{
  "rules": {
    "semi": ["error", "always"],
    "quote": ["error", "double"]
  }
}
        </code></pre>
        <p>
          semi、quote 就是 ESLint 規則的名稱，其值對應的陣列第一項可以為
          off/0、warn/1、error/2，分別表示關閉規則、以 warning 形式開啟規則、以 error 形式開啟規則。
        </p>
        <p>同樣，還會在 .eslintrc 檔案中發現以下內容，表示 ESLint 的預設規則都將被開啟。</p>
        <pre><code class="language-js">
"extends": "eslint: recommended"
        </code></pre>
        <p>當然，也可以選取其他規則集合，此較出名的有以下兩個。</p>
        <ul>
          <li>Google JavaScript Style Guide</li>
          <li>Airbnb JavaScript Style Guide</li>
        </ul>
        <p>繼續拆分 .eslintrc 檔案，可以看到它主要由 6 個欄位組成，程式如下。</p>
        <pre><code class="language-js">
module.exports = {
  env: {},
  extends: {},
  parser: {},
  parserOptions: {},
  rules: {},
}
        </code></pre>
        <ul>
          <li>env：指定啟用的環境。</li>
          <li>extends：指定額外設定的選項，如 ['airbnb'] 表示使用 Airbnb 的 linting 規則。</li>
          <li>plugins 設定規則外掛程式。</li>
          <li>parser：預設情況下，ESLint 使用 espree 進行解析。</li>
          <li>parserOptions：如果更改了預設解析器，則需要設定 parserOptions 來自訂解析器。</li>
          <li>rules：定義擴充的及透過外掛程式增加的所有規則。</li>
        </ul>
        <p>
          注意，上述程式採用了.eslintrc.js 的 JavaScript 檔案格式，此外還可以採用.yaml、.json、yml
          等格式。如果專案中含有多種設定檔格式，則優先順序順序如下。
        </p>
        <pre><code class="language-js">
.eslintrc.js
.eslintrc.yaml
.eslintrc.yml
.eslintrc.json
.eslintrc
.package.json
        </code></pre>
        <p>最後，可以在 package.json 中增加 scripts，如下所示。</p>
        <pre><code class="language-js">
"scripts": {
  "lint": "eslint --debug src/"
  "lint:write": "eslint --debug src/ --fix"
}
        </code></pre>
        <p>
          scripts 中的 lint
          將檢查所有檔案，並在每個存在錯誤的檔案中提供詳細記錄檔，但開發者需要手動開啟這些檔案並更正錯誤；lint:write
          與 lint 類似，但它可以自動校正錯誤。
        </p>
        <h4>linter 和 prettier</h4>
        <p>
          應該如何比較以 ESLint 為代表的 linter 和 prettier
          呢？它們到底是什麼關係？就像本篇開頭所提到的那樣，它們用來解決不同的問題，定位不同，但又可以相輔相成。
          所有的 linter 都與 ESLint 類似，其規則可以劃分為以下兩種。
        </p>
        <p>1.格式化規則（formatting rule）</p>
        <p>
          典型的格式化規則有
          max-len、no-mixed-spaces-and-tabs、keyword-spacing、comma-style，它們有「限制一行的最大長度」、「禁止使用空格和Tab
          混合縮排」等程式格式方面的標準。事實上，如果開發者寫出的程式違反了這種規則，且在 lint
          階段前需要先經過 prettier 進行處理，那麼這些問題就會先在 prettier 階段被校正，因此 linter
          不會拋出提醒，非常讓人省心，這是 linter 和 prettier 重疊的地方。
        </p>
        <p>2.程式品質規則（code quality rule）</p>
        <p>
          程式品質規則有
          no-unused-vars、no-extra-bind、no-implicit-globals、prefer-promise-reject-errors，它們有「限制宣告未使用變數」、「限制不必要的函數綁定」等程式寫法方面的標準。這時，prettier
          對這些規則就無法進行審查和美化了。但是，這些規則對於程式品質和強健性非常重要，還是需要
          linter 來保障的。
        </p>
        <p>
          如同 prettier, ESLint 也可以被整合到編輯器或 git pre-commit 階段。前面已經示範過了
          prettier 搭配 husky 的使用方式，下面就來介紹一下 husky 。
        </p>
        <h4>husky 和 lint-staged</h4>
        <p>
          其實：husky 就是透過 Git 指令的勾子，在 Git
          指令進行到某一時段時，可以被交給開發者完成某些特定的操作。安裝 husky 的指令如下。
        </p>
        <pre><code class="language-bash">
yarn add --dev husky
        </code></pre>
        <p>然後，在 package.json 檔案中增加以下內容。</p>
        <pre><code class="language-js">
"husky": {
  "hooks": {
    "pre-commit": "YOUR_SCRIPT",
    "pre-push": "YOUR_SCRIPT"
  }
}
        </code></pre>
        <p>
          這樣，每次提交（commit）或發送（push）程式時，就可以執行相關 npm
          指令稿。需要注意的是，在整個專案上執行 lint
          會很慢。一般只會對更改的檔案進行檢查，這時就需要用到 lint-staged，如下所示。
        </p>
        <pre><code class="language-bash">
yarn add --dev lint-staged
        </code></pre>
        <p>然後，在 package.json 檔案中增加以下內容。</p>
        <pre><code class="language-js">
"lint-staged": {
  ".(js|jsx)": ["npm run lint:write", "git add"]
}
// 最後程式如下。
"scripts": {
  "lint": "eslint --debug src/",
  "lint:write": "eslint --debug src/ --fix"
  "prettier": "prettier --write src/**/*.js"
},
"husky": {
  "hooks": {
    "pre-commit": "lint-staged"
  }
},
"lint-staged": {
  "*.(js|jsx)": ["npm run lint:write", "npm run prettier", "git add"]
}
        </code></pre>
        <p>
          這段程式表示在 pre-commit 階段使用 ESLint 和 prettier 對副檔名為 js 或 jsx
          且進行過修政的檔案進行處理，之後再透過 git add 指令將本次改動增加到暫存區。
        </p>
        <h3>工具背後的技術原理和設計</h3>
        <p>
          在這一節中，挑選實現更為複雜精妙的 ESLint 進行分析。大家都清楚，ESLint
          是以抽象語法樹（AST）進行工作為基礎的，AST 已經不是一個新鮮話題。ESLint 使用 espree 來解析
          JavaScript 敘述，產生AST。有了完整的解析樹，就可以基於解析樹對式進行檢測和修改了。
        </p>
        <p>
          ESLint
          的靈魂是其中的每筆規則，每筆規則都是獨立且外掛程式化的，下面選擇比較簡單的「禁止區塊級註釋規則」的原始程式來分析。
        </p>
        <pre><code class="language-js">
module.exports = {
  meta: {
    docs: {
      description:'禁止區塊級註釋',
      category: 'Stylistic Issues',
      recommended: true
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode()
    return {
      Program(){
        const comments = sourceCode.getAllComments()
        const blockComments = comments.filter(({ type }) => type === 'Block')
        blockComments.length && context.report({
          message: 'No block comments'
        })
      }
    }
  }
}
        </code></pre>
        <p>
          從中可以看出，一筆規則就是一個 node 模組，它由 meta 和 create 組成。meta
          包含了該筆規則的文件描述，相對簡單；而 create 會接收一個 context 參數，傳回一個物件。
        </p>
        <p>
          同時，create 可以從 context
          中取得目前執行的程式，並透過選擇器取得目前需要的內容。如以上程式所示，會取得程式的所有
          comments (sourceCode.getAIlComments())，如果 blockComments 的長度大於
          0，則會顯示出錯，拋出 No block comments 資訊。
        </p>
        <p>再來看一個 no-console 規則的實現，程式如下。</p>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
      </article>
    </main>
  </body>
  <script type="module" src="./js/main.js"></script>
</html>
