<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JavaScript-syntax-learning</title>
    <link rel="stylesheet" href="./hightlight/default.min.css" />
    <link rel="stylesheet" href=" https://necolas.github.io/normalize.css/8.0.1/normalize.css" />
    <link rel="stylesheet" href="./css/main.css" />
    <script src="./hightlight/hightlight.min.js"></script>
    <script>
        hljs.highlightAll();
    </script>
</head>

<body>
    <nav>
        <h1>現代 Javascript 實務應用</h1>
    </nav>
    <main>
        <aside></aside>
        <section>
            <h2>4-1 Promise</h2>
            <h3 id="4-1-1">4-1-1 開始學習 Promise</h3>
            <p>
                瀏覽器所支援的新的 fetch API。個
                相當於簡化版的 XMLHttpRequest 。
                旨在提供使用者一個非常簡單的方式
                處理經常使用的案例 : 也就是以 HTTP 資源發送 GET 請求。
                基本的使用方式,可建立一個GET items HTTP 請求。
            </p>
            <pre><code class="language-js">
fetch('/items ')
 </code></pre>
            <p>他會對 /items 建立一個「開始並遺忘」的GET 請求，代表不管所送出的請求是否成成功，
                可以忽略回覆並續向下软行。fetch 方法會回傳一個Promise 物件。
                你可以於該Promise 物利用 .then 方法鏈結一個回呼函式，當/items 資源完成載入並接收到 response 物件便會執行指定的回呼函式
            </p>
            <pre><code class="language-js">
fetch('/items').then(response => {
  // 執行某些動作
})
 </code></pre>
            <p>
                以下的程式碼展示以 Promise 為基礎的 API
                利用他便可以將 fetch 於
                瀏覽器端完整際地實作。呼叫 fetch 函式會取得一個Promise 物件，
                就如事件一般你可以利用 .then 和 .catch 方法，該情境下應進行的動作進行繫結。
            </p>
            <pre><code class="language-js">
 const p = fetch('/items')
 p.then(res => {
  // 處理回應
 })

 p.catch(err => {
  // 處理錯誤
 })
 </code></pre>
            <p>.then 區塊中的動作是用以處理 Promise 請求完成後的情况，
                他在完成後提供一個履行完畢的值 ; 而 .catch 中的動作,
                是用以處理請求錯誤的情況,它會提供一個錯誤的原因。你也可以將錯誤的捕捉處理理於 .then 中、那麽上的程式碼則改寫如下。
            </p>
            <pre><code class="language-js">
const p = fetch('/items')
p.then(
res =>{
  // 處理回應
},
err => {
  // 處理错誤
}
 </code></pre>
            <p>
                一種替代方案是忽略對 .then(fulfillment,rejection) 的處理。
                這會與呼叫 .then 時，發生請求被拒絕的狀況但忽略不處理的情形類似。
                .then(null, rejection) 與 .catch(rejection) 在使用上有相同效果,如以下範例所示。
            </p>
            <pre><code class="language-js">
const p = fetch('/items')
p.then(res => {
  // 處理回應
})

p.then(null, err => {
  // 處理錯誤
})
 </code></pre>
            <div class="border-block">
                <h3>以Promise 作為回呼函式與事件的替代方案</h3>
                <p>
                    傳統上·JavaScript較為仰賴回呼函式·而非Promise和健結
                    (chaining)如果fetch函式需要一个回呼函式·那麼你象
                    加入一个函式,且此函式在fetch行完畢後必定會被教行·
                    在Node.js中典型的非同步程式流程慣例,將回呼函式的
                    的第一個參數保留給錯誤物件使用一即使錯誤不一定會發生一
                    在執行fetch的流程中,其餘的参數便可用以擷取非同步操作
                    的結果最常被使用的,是單一个資料参數的狀況·下面的程
                    式碼示範·若fetch具有一个回呼函式AP·它如何被操作
                    使用。

                </p>
                <pre><code class="language-js">
fetch('/items', (err, res) => {
if (err) {
    // 處理錯誤
} else {
   //處理回應
}
})
</code></pre>
                <p>
                    items資源取得之後,回呼函式才會被執行
                    fetch操作發生錯誤時。指令仍然為非同步執行且非阻塞式(nonBlocking)。注意在個模型下你只能夠指定一
                    個回呼,而此函式需負責處理所有的回覆情况;且仰賴使用者建立一種機制,可將各種不同面向的回應處理整合於一個回呼函式中。

                    除傳統的回呼函式之外,另一種 API 設計可選擇使用事件驅動的模型。在此情境下,自 fetch 回傳的物件必須能夠
                    為不同事件註冊回呼函式,為各種事件可能地繫結對應的事件處理器。就如將事件監聽器繫結至瀏覽器的DOM物件。當運作發生問題時,便喚起 error 事件;且當
                    值測到的錯誤也發生時對應的事件也會被喚醒。
                <pre><code class="language-js">
fetch('/items ')
.on('error', err => {
   // 處理錯誤
})
.on('data', res => {
  // 處理回應
}
</code></pre>
                <p>
                    對每一種事件類別結多個事件監聽器,可去除稍早前我們所討論於單一回呼函式集中處理所有的回應的議題。
                    然而,這也讓事件難以鏈結回呼函式,且當另一個非同步工作完成也會讓事件觸發;而這也就是 Promise 可以協助之處。此之外事件較適合用於一連串的值的處理,使得它在某些特殊的情況下不適合使用。
                </p>
            </div>
            <p>
                談到 Promise 物件,鏈結常是一個頭痛的問題。在以事件為
                基礎的 API 中, 藉由 .on 方法的使用可與事件處理器鏈結,並接著回到事件本體。但 Promise 則不同， .then .catch 方法每次均會回傳一個新的
                Promise 物件。這個觀念是很重要的,因為依據所鏈結的方法是 .then 或 .catch ，這會使程式較容易被理解推論。const 鏈結會產生完全不同的結果。
            </p>
            <div class="border-block">
                <h3>視覺化Promise:理解常見的觀念混淆問題</h3>
                <p>
                    .then和·catch方法每次均回傳一個新的 Promise 物件，
                    因此會建立了一個類似樹的資料結構。如果你具有名稱為 p1 的 Promise 物件,以及 p1.then所回傳的 p2 物件,那麼可將 p1 和 p2 視為連接至 p1.then
                    回應處理器的節點。這樣的
                    回應處理器會建立新的 Promise ,並連接至樹結構構中,作為它回應的 Promise 節點的子節點。

                    當鏈結 Promise 物件時，我們必瞭解 p1.then(r1).then(r2)
                    會建立兩個新的 p2 和 p3 的Promise 物件; 第二個回應處理,
                    r2,會於 p2 完成後被啟動; 而 r1 則是於 p1 完成後啟動。若是我們的敘述是以 p1.then(r1); p1.then(r2)的方式撰寫,那麼當 p1 完成時, r1 與 r2
                    均會啟動執行。比較上述兩情境,當 p1 完成而 p2 尚未完成時,就會發生不一致的狀況了。
                    釐清 Promise 物件的類樹狀結構的本質,是更進一步理解
                    Promise 物件運作的關鍵點。最後,我建立了一個線上的工具,
                    稱為 (<a href="https://bevacqua.github.io/promisees/">Promisees</a> ),你可以
                    使用他將所撰寫的 Promise 鏈結轉換為其所代表的樹狀結構圖
                </p>
            </div>

            <p>
                要建立一個 Promise 物件,需要傳遞一個解析器(resolver)至 Promise 中，解析器可決定該 Promise 如何與何時完成確認(settled); 它會藉由呼叫 resolve 方法將
                Promise 物件確認為已實現狀態;
                (fulfillment);或是呼叫 reject 方法將 Promise 物件確認為已拒絕狀態 (rejection) 在兩個函式之一被呼叫之前,他會處於一個暫停的
                (pending) 的狀態,且所有與之繫結的回應都不會被執行。以下的程式將示範如何從頭開始建立一個 Promise物件,但先已亂數的 方式將 Promise 物件確認為已實現或已拒絕的狀態。

            </p>
            <pre><code class="language-js">
new Promise(function (resolve, reject) {
    setTimeout(function () {
        if (Math.random() > 0.5) {
            resolve('random success')
        }else if {
            reject(new Error('random failure'))
    }, 1000)
})
</code></pre>
            <p>
                Promise 物件也可以利用 Promise.resolve 和 Promise.reject 建立。用這
                些方法建立 Promise 物件,可立即確認具有一個實現值(fulfillment value),或是具有一個拒絕原因的物件。
            </p>
            <pre><code class="language-js">
Promise
.resolve({result:123})
.then(data =>console.log(data.result))
//  123
</code></pre>
            <p>
                當一個 Promise 物件 p 為已實現狀態時,註冊於 p.then的回應便會被執行;當 p 為已拒絕狀態時,註冊於 p.catch的回應便會被執行。這些
                回應會依順序產生三種不的情況,根據它們的回傳值為一個值、一個 Promise 物件、一個 thenable 物件或利用throw 拋出錯誤。Thenable 物件被視為類 promise 的物件,可利用
                Promise.resolve 將它
                轉換為 Promise 物件。
            </p>
            <p>
                一個回應可能會回傳一個值,它藉由 .then 回傳一個已實現的 Promise 物件並附帶一實現值。在此狀下,
                Promise 物件可以被繫結，以將上一個 Promise 物件的實現值進行轉換,依此類推反覆進行,如下面程式碼所示
            </p>
            <pre><code class="language-js">
Promise
.resolve(2)
.then(x=>x*7)
.then(x=>x-3)
.then(x=> console.log(x))
// 11
            </code></pre>
            <p>
                一個回應也會回傳一個 Promise 物件,對比上一個範例程式,下面程式碼等待呼叫第一個 .then 所回傳的物件 , 須至它的回應已實現後，才能夠取得;
                因為 setTimeout 的函式呼叫,需要大約 2 秒鐘後才
                會確認為已實現的狀態。
            </p>
            <pre><code class="language-js">
Promise
.resolve(2)
.then(x => new Promise(function (resolve) {
    setTimeout(()=> resolve(x*1000),x*1000)
}))
.then(x =console.log(x)
// 2000
            </code></pre>
            <p>
                一個回應也可能以 throw 拋出錯,會使 .then 所回傳的Promise 物件成為已拒絕狀態，並接著進入 .catch 的分支區塊 , 以 error 物件作為拒絕的原因。以下程式範例展示如何於
                fetch 操作加上一個已實現的回應 ; 當 fetch 為已實現狀態時,在回應中會抛出一個錯誤,並産生一個已拒絕的回應，繫結於執行 .then 後所回傳的 Promise 物件上。
            </p>
            <pre><code class="language-js">
const p = fetch('/items')
.then(res => { throw new Error('unexpectedly')})
.catch(err => console.error(err))
            </code></pre>
            <h3 id="4-1-2">4-1-2 Promise 物件的再開始和連結</h3>
            <P>
                當在 Promise 的解析中發生錯誤時，可利用 p.catch 捕捉到錯誤 ，如下方範例。
            </P>
            <pre><code class="language-js">
new Promise((resolve, reject) => reject(new Error('oops'))).catch(err=> console.error(err))
            </code></pre>
            <P>
                當 Promise 的解析器呼叫了 reject 後，便會確認成為已拒絕狀態; 但是若再解析器中有拋出錯誤時，也會進入已拒絕狀態，如下範例所示。
            </P>
            <pre><code class="language-js">
new Promise((resolve, reject) => {
    throw new Error('oops')
}).catch(err =>console.error(err))
             </code></pre>

            <P>
                當執行一個已實現或已拒絕的回應時發生了錯誤,也會有相同的行為; 會自 .then 中回傳一個已拒絕的 Promise 物件,或自發生錯誤進入 .catch 方法後回傳。看完以下的程式範例應會較容易瞭解。
            </P>
            <pre><code class="language-js">
Promise.resolve(2).then(x => {throw new Error('failed') })
.catch(err =>console.error(err))           
           </code></pre>
            <P>
                將一連串的鏈結方法拆解為多個變數說明,會較容易理解其觀念,如下方程式碼所示。這段程式可幫助你視覺化以下觀念; 若 .catch 回應繫結至 p1 , 你就不需要於 .then 回應中補捉可能發生的錯誤。當
                p1 已確認實現時, p2 不同於 p1 的 Promise 物件,回傳自 p1.then 。因拋出錯誤故成為已拒絕狀態; 而繫結於 p2 的已拒絕的回應,則會捕捉到所抛出的錯誤。
            </P>
            <pre><code class="language-js">
const p1 = Promise.resolve(2) 
const p2 = p1.then(x => { throw newError('failed')})
const p3 = p2.catch(err => console.error(err))               
             </code></pre>
            <p>
                此處另一種情境可協助你以類樹狀的資料結構去思考Promise 概念。若在 p2 節點發生了錯誤，繫結於 p1 節點上的已拒絕狀態的回應是不會捕捉到的。
                如下方範例。
            </p>
            <p>
                已經瞭解,將回應繫結於正確的 Promise 物件上很重要。
                影響到是否可正確地捕捉到所發生的錯誤。值得注意的是
                Promise 物件鏈結上有未捕捉到的錯誤,拒絕處理器都可以捕捉到。
                以下的例子中,我們在 p2 和 p4 中間插入了一個 .then 呼叫;
                p2 是發生錯誤之處,p4 是繫結拒絕處理器的位置。當 p2 確認為已拒絕時，
                p3 便也確認為已拒絕狀態,因為它直接與 p2 的結果相關連;當 p3 為已拒時,
                在 p4 的拒絕處理器便會啟動。
            </p>
            <pre><code class="language-js">
const p1 = Promise.resolve(2)
const p2 = p1.then(x => { throw new Error('failed')})
const p3 = p2.then(x=>x *2)
const p4 = p3.catch(err => console.error(err))
            </code></pre>
            <p>
                基本上 p4 是已實現的狀態,因為在 .catch 的拒絕處理器
                並不會發再產生其他錯誤。這表示若加入 p4.then 的實現處理器,便一定會被執行。
                以下的範例說明,如何透過 p4 的實現理器,將文字敘述
                輸出至瀏覽器的控制終端中,該處理器在 p3 確認為已實現的狀態後便會執行。
            </p>
            <pre><code class="language-js">
const p1 = Promise.resolve(2)
const p2 = p1.then(x => { throw new Error('failed') })
const p3 = p2.catch(err => console.error(err))
const p4 = p3.then(() => console.log('crisis averted'))
            </code></pre>
            <p>
                同理,如果在 p3 的拒絕處理器中發生,我們也可利用。.catch捕捉到該錯誤。下面的程式碼說明如何使用p3.catch 捕捉到自p3所拋出的錯誤,就像是在前幾個捕捉錯誤的範例一樣。
            </p>

            <pre><code class="language-js">
const p1 = Promise.resolve(2)
const p2 = p1.then(x => { throw new Error('failed')})
const p3 = p2.catch(err => { throw new Error('oops') })
const p4 = p3.catch(err => console.error(err))
            </code></pre>
            <p>
                下面的例子會將 err.message 印出一次,而非兩次:因為在第一個 .catch 中並未發生錯誤,故所回傳的 Promise 物件其繫結的拒絕處理器並不會被執行。
            </p>
            <pre><code class="language-js">
fetch('/items')
.then(res => res.a.prop.that.does.not.exist)
.catch(err =>console.error(err.message))
.catch(err => console.error(err.message))
// 'cannot read property "prop" of undefined'
            </code></pre>

            <p>
                相反的，下方的例子則會將 err.message 印出兩次:程式
                會先儲存 .then 所回傳的 Promise 物件的參考,接著將兩個 .catch 繫結於物件上; 在上一個範例中，第二個 .catch 會處理第一個 .catch 所回傳的 Promise 物件
                拋出的錯誤 ;但在此範例中,這兩個拒絕處理器都會處理 p 所拋出的錯誤。
            </p>
            <pre><code class="language-js">
const p = fetch('/items').then(res =>
    res.a.prop.that.does.not.exist
)
p.catch(err => console.error(err.message))
p.catch(err =>console.error(err.message))
//  'Cannot read property "prop" of undefined"
//  'Cannot read property "prop" of undefined"
            </code></pre>
            <p>
                所以，Promise 物件能夠任意地鏈結方法 ; 就如前面我們所看到的例子，在 Promise 物件的方法鏈捷中，可於任何的位置儲存 Promise 物件的參考，並於該物件上附加産生更多的 Promise
                物件。這是一個瞭解 Promise 運作的重要觀念。
            </p>
            <p>
                下面的範例列出事件啟動的順序,自 Promise 物件的建立和結·讓我們一起看看以下的程式碼。
            </p>
            <pre><code class="language-js">
                const p1 = fetch('/items')
                const p2 = p1.then(res => res.a.prop.that.does.not.exist)
                const p3 = p2.catch(err => {})
                const p4 = p3.catch(err=>console.error(err.message))
            </code></pre>

            <p>
                下面逐步說明程式碼執行的過程:
                1. fetch 回傳一個全新的 p1 物件。
                2. p1.then 回傳一個全新的 p2 物件,當 p1 為已實現狀態時便會執行。
                3. p2.catch 回傳一個全新的 p3 物件,當 p2 為已拒絕狀態時便會執行。
                4. p3.catch 回傳一個全新的 p4 物件,當 p3 為已拒絕狀態時便會執行。
                5.當 p1 物件為已實現時,便會執行 p1.then 的回應敘述。
                6.因為 p1.then 的回應中拋出錯誤，故 p2 物件為已拒絕狀態。
                7.因為 p2 物件為已拒絕狀態,便會執行 p2.catch ,若有 p2.then 的回應處理器則會被略過不執行。
                8. p2.catch 所回傳的 p3 物件為已實現狀態,因為在一個已拒絕的
                Promise 物件不會再產生錯誤,或回傳一個已拒絕的物件。
                9.因為 p3 物件為已實現，便不會執行 p3.catch , 若有 p3.then 的回應
                處理器則便會執行。
                你可以將 Promise 物件的產生以樹狀結構看待,再強調一次:可用樹狀
                結構看待 Promise 物件的關係1,圖4-4可協助你更具體瞭解這個觀念。
            </p>

        </section>
    </main>
</body>
<script src="./menu.js"></script>

</html>