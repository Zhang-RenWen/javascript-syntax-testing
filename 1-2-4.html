<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="./public/favicon.ico" />
    <meta http-equiv="cache-control" content="no-cache" />
    <title></title>
    <link rel="stylesheet" href=" https://necolas.github.io/normalize.css/8.0.1/normalize.css" />
    <link rel="stylesheet" href="./hightlight/default.min.css" />
    <link rel="stylesheet" href="./css/main.css" />
    <link rel="stylesheet" href="./css/copybutton.css" />
    <link rel="stylesheet" href="./css/hightlight.css" />
    <script src="./hightlight/hightlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BEVZJDBC7Z"></script>
    <script src="./js/gtag.js"></script>
  </head>

  <body>
    <header>
      <nav>
        <h1>
          <span id="toggle-menu"></span>
          <a href="index.html"></a>
        </h1>
      </nav>
    </header>
    <main>
      <aside>
        <nav></nav>
      </aside>
      <article>
        <h2 id="1-2-4">1-2-4 高頻考點及基礎題庫</h2>
        <h3>JavaScript 資料類型及其判斷</h3>
        <p>
          對於類型判斷，常用的方法有 typeof、instanceof、Object.prototype.toString、 constructor。
        </p>
        <h3>使用 typeof 判斷資料類型</h3>
        <pre><code class="language-js">
typeof 5 // "number"
typeof 'lucas' // "string"
typeof undefined // "undefined"
typeof true // "boolean"
        </code></pre>
        <p>但是也存在一些特例，如用 typeof 判斷 null，程式如下。</p>
        <pre><code class="language-js">
typeof null // "object"
        </code></pre>
        <p>判斷複雜資料類型的範例。</p>
        <pre><code class="language-js">
const foo = () => 1
typeof foo // "function"

const too = {}
typeof foo // "object"

const Foo = []
typeof foo // "object"

const foo = new Date ()
typeof too // "object"

const foo = Symbol("foo")
typeof Foo // "symbol"
        </code></pre>
        <p>
          透過以上範例，我們可以知道，使用 typeof 可以準確判斯出除 null 以外的基底資料型態，以及
          function 類型、symbol 類型；null 會被 typeof 判斷為 object 。
        </p>
        <h3>使用 instanceof 判斷資料類型</h3>
        <p>
          a instanceof B 判斷的是，a 是否為 B 的實例，即a 的原型鏈上是否存在 B
          的建構函數，範例程式如下。
        </p>
        <pre><code class="language-js">
function Person (name) {
  this.name = name
}
const p = new Person('lucas')
p instanceof Person
// true
        </code></pre>
        <p>
          p 是 Person 創建出來的實體。同時順著 p 的原型鏈也能找到 Object 的建構函數，範例程式如下。
        </p>
        <pre><code class="language-js">
p.__proto__.__proto__=== Object.prototype
        </code></pre>
        <p>再來看一個範例。如果我們判斷的是以下關係，則傳回 false。</p>
        <pre><code class="language-js">
5 instanceof Number // false
        </code></pre>
        <p>
          因為 5 是基本類型，它並不是 Number
          建構函數建置出來的實例物件。而如果稍加修改，使其變為判斷以下關係，則傳回 true
        </p>
        <pre><code class="language-js">
new Number(5) instanceof Number // true
        </code></pre>
        <p>關於 instanceof 的原理，可以用以下程式來模擬。</p>
        <pre><code class="language-js">
// L表示左運算式， R表示右運算式

const instanceofMock = (L, R) => {
  if (typeof L !== 'object') {
    return false
  }
  while (true) {
    if (L === null) {
      //已經檢查到了頂端
      return false
    }
    if (R.prototype === L.__proto__) {
      return true
    }
    L = L.__proto__
  }
}
        </code></pre>
        <p>根據 L 表示左運算式， R 表示右運算式， instanceofMock 的用法如下。</p>
        <pre><code class="language-js">
instanceofMock('', String)
// false

function Person(name){
  this.name = name
}
const p = new Person('lucas')
instanceofMock(p, Person)
// true
        </code></pre>
        <h3>使用 constructor 和 Object.prototype.toString 判斷資料類型</h3>
        <p>透過 toString 判斷資料類型好用的方法如下所示。</p>
        <pre><code class="language-js">
console.log(Object.prototype.toString.call(1))
// [object Number]
console.log(Object.prototype.toString.call('lucas'))
// [object String]
console.log(Object.prototype.toString.call(undefined))
/ [object Undefined]
console.log(Object.prototype.toString. call(true))
// [object Boolean]
console.log(Object.prototype.toString.call({}))
// [object Object]
console.log(Object.prototype.toString.call([]))
// [object Array]
console.log(Object.prototype.toString.call(function(){}))
// [object Function]
console.log(Object.prototype.toString.call(null))
// [object Null]
console.log(Object.prototype.toString.call(Symbol('lucas')))
// [object Symbol]
        </code></pre>
        <p>
          使用 constructor
          可以檢視目標的建構函數，也可以進行資料類型判斷，但其中也存在問題，實際請看以下範例。
        </p>

        <pre><code class="language-js">
var foo = 5
foo.constructor
// f Number(){ [native code] }
var foo = 'Lucas'
foo.constructor
// f String(){ [native code] }
var foo = true
foo.constructor
// f Boolean(){ [native code] }
var foo = []
foo.constructor
// f Array () { [native code] }
var foo = {}
foo.constructor
// f Object(){ [native code] } 
var foo = () => {}
foo.constructor
// f Function () { [native code] }
var foo = new Date()
foo. constructor
// f Date(){ [native code] }
var foo = Symbol("foo")
foo.constructor
// f Symbol(){ [native code] }
var foo = undefined
foo.constructor
// VM257:1 Uncaught TypeError: Cannot read property 'constructor' of undefined at &lt;anonymous&gt;: 1:5
var foo = null
foo.constructor
// VM334:1 Uncaught TypeError: Cannot read property 'constructor' of null at &lt;anonymous&gt;： 1:5

        </code></pre>
        <p>
          我們發現對於 undefined 和 null，如果嘗試讀取其 constructor 屬性，則會顯示出錯，並且
          constructor 傳回的是建構函數本身，一般使用它來判斷資料類型 的情況並不多見。
        </p>
        <h3>JavaScript 資料類型及其轉換</h3>
        <p>
          先看一個有趣的網站。
          <a href="https://jsfuck.com/" target="_blank" rel="noopener noreferrer">
            https://jsfuck.com/
          </a>
        </p>
        <p>挖掘源代碼可以看到作者利用了 JS 弱型別自動轉換的原理做了一個轉譯器。</p>
        <pre><code class="language-js">
/*! JSFuck 0.5.0 - http://jsfuck.com */

(function(self){
  const MIN = 32, MAX = 126;

  const SIMPLE = {
    'false':      '![]',
    'true':       '!![]',
    'undefined':  '[][[]]',
    'NaN':        '+[![]]',
    'Infinity':   '+(+!+[]+(!+[]+[])[!+[]+!+[]+!+[]]+[+!+[]]+[+[]]+[+[]]+[+[]])' // +"1e1000"
  };

  const CONSTRUCTORS = {
    'Array':    '[]',
    'Number':   '(+[])',
    'String':   '([]+[])',
    'Boolean':  '(![])',
    'Function': '[]["flat"]',
    'RegExp':   'Function("return/"+false+"/")()',
    'Object':	'[]["entries"]()'
  };

  const MAPPING = {
    'a':   '(false+"")[1]',
    'b':   '([]["entries"]()+"")[2]',
    'c':   '([]["flat"]+"")[3]',
    'd':   '(undefined+"")[2]',
    'e':   '(true+"")[3]',
    'f':   '(false+"")[0]',
    'g':   '(false+[0]+String)[20]',
    'h':   '(+(101))["to"+String["name"]](21)[1]',
    'i':   '([false]+undefined)[10]',
    'j':   '([]["entries"]()+"")[3]',
    'k':   '(+(20))["to"+String["name"]](21)',
    'l':   '(false+"")[2]',
    'm':   '(Number+"")[11]',
    'n':   '(undefined+"")[1]',
    'o':   '(true+[]["flat"])[10]',
    'p':   '(+(211))["to"+String["name"]](31)[1]',
    'q':   '("")["fontcolor"]([0]+false+")[20]',
    'r':   '(true+"")[1]',
    's':   '(false+"")[3]',
    't':   '(true+"")[0]',
    'u':   '(undefined+"")[0]',
    'v':   '(+(31))["to"+String["name"]](32)',
    'w':   '(+(32))["to"+String["name"]](33)',
    'x':   '(+(101))["to"+String["name"]](34)[1]',
    'y':   '(NaN+[Infinity])[10]',
    'z':   '(+(35))["to"+String["name"]](36)',

    'A':   '(NaN+[]["entries"]())[11]',
    'B':   '(+[]+Boolean)[10]',
    'C':   'Function("return escape")()(("")["italics"]())[2]',
    'D':   'Function("return escape")()([]["flat"])["slice"]("-1")',
    'E':   '(RegExp+"")[12]',
    'F':   '(+[]+Function)[10]',
    'G':   '(false+Function("return Date")()())[30]',
    'H':   null,
    'I':   '(Infinity+"")[0]',
    'J':   null,
    'K':   null,
    'L':   null,
    'M':   '(true+Function("return Date")()())[30]',
    'N':   '(NaN+"")[0]',
    'O':   '(+[]+Object)[10]',
    'P':   null,
    'Q':   null,
    'R':   '(+[]+RegExp)[10]',
    'S':   '(+[]+String)[10]',
    'T':   '(NaN+Function("return Date")()())[30]',
    'U':   '(NaN+Object()["to"+String["name"]]["call"]())[11]',
    'V':   null,
    'W':   null,
    'X':   null,
    'Y':   null,
    'Z':   null,

    ' ':   '(NaN+[]["flat"])[11]',
    '!':   null,
    '"':   '("")["fontcolor"]()[12]',
    '#':   null,
    '$':   null,
    '%':   'Function("return escape")()([]["flat"])[21]',
    '&':   '("")["fontcolor"](")[13]',
    '\'':  null,
    '(':   '([]["flat"]+"")[13]',
    ')':   '([0]+false+[]["flat"])[20]',
    '*':   null,
    '+':   '(+(+!+[]+(!+[]+[])[!+[]+!+[]+!+[]]+[+!+[]]+[+[]]+[+[]])+[])[2]',
    ',':   '[[]]["concat"]([[]])+""',
    '-':   '(+(.+[0000001])+"")[2]',
    '.':   '(+(+!+[]+[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]]+[+[]])+[])[+!+[]]',
    '/':   '(false+[0])["italics"]()[10]',
    ':':   '(RegExp()+"")[3]',
    ';':   '("")["fontcolor"](NaN+")[21]',
    '<':   '("")["italics"]()[0]',
    '=':   '("")["fontcolor"]()[11]',
    '>':   '("")["italics"]()[2]',
    '?':   '(RegExp()+"")[2]',
    '@':   null,
    '[':   '([]["entries"]()+"")[0]',
    '\\':  '(RegExp("/")+"")[1]',
    ']':   '([]["entries"]()+"")[22]',
    '^':   null,
    '_':   null,
    '`':   null,
    '{':   '(true+[]["flat"])[20]',
    '|':   null,
    '}':   '([]["flat"]+"")["slice"]("-1")',
    '~':   null
  };

  const GLOBAL = 'Function("return this")()';

  function fillMissingDigits(){
    var output, number, i;

    for (number = 0; number < 10; number++){

      output = "+[]";

      if (number > 0){ output = "+!" + output; }
      for (i = 1; i < number; i++){ output = "+!+[]" + output; }
      if (number > 1){ output = output.substr(1); }

      MAPPING[number] = "[" + output + "]";
    }
  }

  function replaceMap(){
    var character = "", value, i, key;

    function replace(pattern, replacement){
      value = value.replace(
        new RegExp(pattern, "gi"),
        replacement
      );
    }

    function digitReplacer(_,x) { return MAPPING[x]; }

    function numberReplacer(_,y) {
      var values = y.split("");
      var head = +(values.shift());
      var output = "+[]";

      if (head > 0){ output = "+!" + output; }
      for (i = 1; i < head; i++){ output = "+!+[]" + output; }
      if (head > 1){ output = output.substr(1); }

      return [output].concat(values).join("+").replace(/(\d)/g, digitReplacer);
    }

    for (i = MIN; i <= MAX; i++){
      character = String.fromCharCode(i);
      value = MAPPING[character];
      if(!value) {continue;}

      for (key in CONSTRUCTORS){
        replace("\\b" + key, CONSTRUCTORS[key] + '["constructor"]');
      }

      for (key in SIMPLE){
        replace(key, SIMPLE[key]);
      }

      replace('(\\d\\d+)', numberReplacer);
      replace('\\((\\d)\\)', digitReplacer);
      replace('\\[(\\d)\\]', digitReplacer);

      replace("GLOBAL", GLOBAL);
      replace('\\+""', "+[]");
      replace('""', "[]+[]");

      MAPPING[character] = value;
    }
  }

  function replaceStrings(){
    var regEx = /[^\[\]\(\)\!\+]{1}/g,
      all, value, missing,
      count = MAX - MIN;

    function findMissing(){
      var all, value, done = false;

      missing = {};

      for (all in MAPPING){

        value = MAPPING[all];

        if (value && value.match(regEx)){
          missing[all] = value;
          done = true;
        }
      }

      return done;
    }

    function mappingReplacer(a, b) {
      return b.split("").join("+");
    }

    function valueReplacer(c) {
      return missing[c] ? c : MAPPING[c];
    }

    for (all in MAPPING){
      if (MAPPING[all]){
        MAPPING[all] = MAPPING[all].replace(/\"([^\"]+)\"/gi, mappingReplacer);
      }
    }

    while (findMissing()){
      for (all in missing){
        value = MAPPING[all];
        value = value.replace(regEx, valueReplacer);

        MAPPING[all] = value;
        missing[all] = value;
      }

      if (count-- === 0){
        console.error("Could not compile the following chars:", missing);
      }
    }
  }

  function escapeSequence(c) {
    var cc = c.charCodeAt(0);
    if (cc < 256) {
      return '\\' + cc.toString(8);
    } else {
      var cc16 = cc.toString(16);
      return '\\u' + ('0000' + cc16).substring(cc16.length);  
    }
  }

  function escapeSequenceForReplace(c) {
    return escapeSequence(c).replace('\\', 't');
  }

  function encode(input, wrapWithEval, runInParentScope){
    var output = [];

    if (!input){
      return "";
    }

    var unmappped = ''
    for(var k in MAPPING) {
      if (MAPPING[k]){
        unmappped += k;
      }
    }
    unmappped = unmappped.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    unmappped = new RegExp('[^' + unmappped + ']','g');
    var unmappedCharactersCount = (input.match(unmappped) || []).length;
    if (unmappedCharactersCount > 1) {
      // Without this optimization one unmapped caracter has encoded length
      // of about 3600 characters. Every additional unmapped character adds 
      // 2000 to the total length. For example, the lenght of `~` is 3605, 
      // `~~` is 5600, and `~~~` is 7595.
      // 
      // The loader with replace has encoded length of about 5300 characters
      // and every additional character adds 100 to the total length. 
      // In the same example the length of `~~` becomes 5371 and `~~~` -- 5463.
      // 
      // So, when we have more than one unmapped character we want to encode whole input
      // except select characters (that have encoded length less than about 70)
      // into an escape sequence.
      //
      // NOTE: `t` should be escaped!
      input = input.replace(/[^0123456789.adefilnrsuN]/g, escapeSequenceForReplace);
    } else if (unmappedCharactersCount > 0) {
      //Because we will wrap the input into a string we need to escape Backslash 
      // and Double quote characters (we do not need to worry about other characters 
      // because they are not mapped explicitly).
      // The JSFuck-encoded representation of `\` is 2121 symbols,
      // so esacped `\` is 4243 symbols and escaped `"` is 2261 symbols
      // however the escape sequence of that characters are 
      // 2168 and 2155 symbols respectively, so it's more practical to 
      // rewrite them as escape sequences.
      input = input.replace(/["\\]/g, escapeSequence);
      //Convert all unmapped characters to escape sequence
      input = input.replace(unmappped, escapeSequence);
    }

    var r = "";
    for (var i in SIMPLE) {
      r += i + "|";
    }
    r+= ".";

    input.replace(new RegExp(r, 'g'), function(c) {
      var replacement = SIMPLE[c];
      if (replacement) {
        output.push("(" + replacement + "+[])");
      } else {
        replacement = MAPPING[c];
        if (replacement){
          output.push(replacement);
        } else {
          throw new Error('Found unmapped character: ' + c);
        }
      }
    });

    output = output.join("+");

    if (/^\d$/.test(input)){
      output += "+[]";
    }

    if (unmappedCharactersCount > 1) {
      // replace `t` with `\\`
      output = "(" + output + ")[" + encode("split") + "](" + encode ("t") + ")[" + encode("join") +"](" + encode("\\") + ")";
    }

    if (unmappedCharactersCount > 0) {
      output = "[][" + encode("flat") + "]"+
      "[" + encode("constructor") + "]" +
      "(" + encode("return\"") + "+" + output + "+" + encode("\"") + ")()";
    }

    if (wrapWithEval){
      if (runInParentScope){
        output = "[][" + encode("flat") + "]" +
          "[" + encode("constructor") + "]" +
          "(" + encode("return eval") + ")()" +
          "(" + output + ")";
      } else {
        output = "[][" + encode("flat") + "]" +
          "[" + encode("constructor") + "]" +
          "(" + output + ")()";
      }
    }

    return output;
  }

  fillMissingDigits();
  replaceMap();
  replaceStrings();

  self.JSFuck = {
    encode: encode
  };
})(typeof(exports) === "undefined" ? window : exports);

        </code></pre>
        <p>如需用在自己的小功能可以這樣使用。當然這是一個很鬧的展示，不可能用在正式產品上。</p>
        <pre><code class="language-js">
function $(id){
  return document.getElementById(id);
}

function encode(){
  var output = JSFuck.encode($("input").value, $("eval").checked, $("scope").checked);
  $("output").value = output;
  $("stats").innerHTML = output.length + " chars";
}

$("encode").onclick = encode;
$("eval").onchange = encode;
$("scope").onchange = encode;

encode();

$("run").onclick = function(){
  value = eval($("output").value)
  if (!$("eval").checked){
    alert('"' + value + '"');
  }
  return false;
};
        </code></pre>
        <p>
          用以上轉譯器轉出來的一串怪怪的符號組合，拿到執行環境去跑還真的可以執行。只能說 JS
          真的是太神奇了。
        </p>
        <p>
          JavaScript
          是一種弱類型，或說是一種動態語言。這表示你不用提前宣告變數的資料類型，在程式執行過程中，變數的資料類型會被自動確定。
        </p>
        <p>如果覺得上面的例子太過燒腦，下面有列舉一些基本案例。</p>
        <pre><code class="language-js">
console.log( 1 + '1' )
// 11
console.log( 1 + true )
// 2
console.log( 1 + false )
// 1
console.log( 1 + undefined )
// NaN
console.log( 'lucas' + true )
// lucastrue
console.log( 1+ true )
// 2
console.log( 1 + false )
// 1
console.log( {} + true )
// [object Object]true
console.log( [] + {} )
// [object Object]
console.log( [] + [] )
// ''
console.log( [] + 1 )
// '1'
console.log( [] + 0 )
// '0'

        </code></pre>
        <p>在＋運算子兩側，如果存在複雜資料類型，例如物件，會遵循的一套轉換規則。</p>
        <p>
          當使用＋運算子計算時，如果存在複雜資料類型，那麼它將被轉為基底資料型態再進行運算。這就有關「物件類型轉基本類型」這個過程。這個過程的實際規則是，在轉換時，會呼叫該物件上的
          valueOf或 toString 方法，這兩個方法的傳回值是轉換後的結果。
        </p>
        <p>
          那實際呼叫 valueOf 還是 toString 呢？這是 ES 標準所決定的，實際上，這取決於內建的
          toPrimitive
          的呼叫結果。從主觀上說，這個物件偏好轉換成什麼，就會優先呼叫哪個方法。如果偏好轉為 number
          類型，就優先呼叫valueOf；如果偏好轉為 string 類型，就只呼叫
          toString。這裡建議大家了解一些常用的轉換結果，對於其他特例情況，會尋找標準即可。
        </p>
        <p>
          很多經典教科書中介紹將物件轉為基底資料型態時，會先呼叫 valueOf，再呼叫
          toString，這裡引用的「這個物件偏好轉換成什麼，就會優先呼叫哪個方法」其實取自標準中的
          PreferredType 概念，這個概念在這些書中並沒有被提到。事實上，瀏覽器對 PreferredType的
          了解比較一致，「物件類型轉為基本類型時，先呼叫 valueOf，再呼叫
          toString」也沒有問題。對此有興趣或更加嚴謹可以翻閱相關標準。
        </p>
        <p>valueOf 及 toString 是可以被開發者重新定義的，範例如下。</p>
        <pre><code class="language-js">
const foo = {
  toString(){
    return 'lucas'
  },
  valueOf(){
    return 1
  }
}
        </code></pre>
        <p>
          我們對 foo 物件的 valueOf及 toSting 進行了重新定義，這時候呼叫 alert(foo)將輸出
          lucas。這裡就有關自動轉型，在呼叫 alert 列印輸出時，偏好使用 foo 物件的toString 方法，將
          foo 轉為基底資料型態，以列印出結果。
        </p>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
      </article>
    </main>
  </body>
  <script type="module" src="./js/main.js"></script>
  <script></script>
</html>
