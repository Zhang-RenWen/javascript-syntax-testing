<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>JavaScript-syntax-learning</title>
  <link rel="stylesheet" href="./hightlight/default.min.css" />
  <link rel="stylesheet" href=" https://necolas.github.io/normalize.css/8.0.1/normalize.css" />
  <link rel="stylesheet" href="./css/main.css" />
  <script src="./hightlight/hightlight.min.js"></script>
  <script>
    hljs.highlightAll();
  </script>
</head>

<body>
  <nav>
    <h1>現代 Javascript 實務應用</h1>
  </nav>
  <main>
    <aside></aside>
    <section>
      <h2>4-3 產生器函式和產生器物件</h2>
      <p>
        產生器是 ES6 新的特徵功能。它運作的方式是。你可以宣告一個產生器函式，函式會回傅產生器物件 B。這些 B 物件可使用 Array.from(g)、[...g]、或 for..of
        迴圈進行迭代。產生器函式可以允許宣告一個特殊的
        iterator 迭代器，這種迭代器可暫停執行並保留其內容。
      </p>
      <h3 id="4-3-1">4-3-1 產生器基礎元素</h3>
      <p>
        我們已經在上一個章節中仔細瞭解了迭代器的運作，學習如何呼叫 .next() 方法自序列中擷取值。當你需要回傳一個值時，除了使用 next 方法之外，產生器可使用關鍵字 yield 將值加入至序列中。
        這裡有一個產生器函式的範例。請注意在 function 之後的 * 符號，這並不是印刷錯誤，而是將一個函式標示為產生器函式的語法。
      </p>
      <pre><code class="language-js">
function* abc(){
  yield 'a'
  yield 'b'
  yield 'c'
}
        </code></pre>
      <p>
        產生器物件同時遵守可迭代協議和迭代器協議：
      <ul>
        <li>
          一個產生器物件 chars 是以abc 函式建立
        </li>
        <li>
          物件 chars 是一個可选代物件，因為它具有一個 Symbol.iterator 方法
        </li>
        <li>
          物件 chars 也是一個迭代器，因為它具有一個 .next 方法
        </li>
        <li>
          chars 的迭代器就是它自己
        </li>
      </ul>
      以 JavaScript 程式碼表示如下。
      </p>
      <pre><code class="language-js">
const chars = abc()
typeof chars[Symbol.iterator] === 'function'
typeof chars.next === 'function'
chars[Symbol.iterator]() === chars
console.log(Array.from(chars))
// ['a','b','c']
console.log([...chars])
// ['a','b','c']
      </code></pre>



      <pre><code class="language-js">
console.log([...numbers ()])
// 'a'
// 'b'
// 'c'
// [1, 2, 3]
        </code></pre>
      <p>
        若我們現在以 for..of 迴圈取代,就能夠保留住宣告於 numbers 產生器函式的輸出順序。在下方的範例中，numbers 序列的資料項在每次的 for..of 迴圈中會被印出一次。第一次產生器函式被要求一個
        number 數值時，它會回傳 1 後便暫停執行，第二次，產生器函式會自上次暫停處
        恢復執行，並輸出 'a' 至控制終端，接著將 2 產出;第三次，輸出 'b'
        並產出了 3；第四次，輸出 'c' 且產生器會發現序列已結束。
      </p>
      <pre><code class="language-js">
for (const number of numbers ()) {
  console.log(number)
}      
// 1
// 'a'
// 2
// 'b'
// 3
// 'c'
        </code></pre>
      <p>
        當建立了一個產生器物件時，你會取得一個迭代器，它會使用產生器函式產出可迭代序列。當執行到 yield 叙述時，迭代器會將它的值送出且會暫停產生器函式的執行。
      </p>
      <p>
        以下範例說明，在產生器函式中的迭代行為如何觸發執行一些周邊的敘述。當產生器函式恢復執行且要求序列的下一個資料項時，每個 yield 敘述後的 console.log 敘述將被執行。
      </p>
      <pre><code class="language-js">
function* numbers () {
  yield 1
  console.log('a' )
  yield 2
  console.log(' b' )
  yield 3
  console.log('c')
}
        </code></pre>
      <p>
        假設你用 numbers 建立了一個產生器物件，將它的資料內容展開至陣列中，並輸出至控制終端。考量一下發生在 numbers
        的周邊敘述的執行，你可以猜想下方的程式碼輸出的結果為何嗎？展開運算子會巡訪序列所有資料項，以提供你一個結果陣列;當透過解構賦值的方式建立陣列時，所有的周邊敘述會在
        console.log 印出陣列值之前就完成執行。
      </p>
      <div class="border-block">
        <h3>使用 yield* 委派以產生序列</h3>
        <p>產生器函式可以使用 yield* 去委派一個產生器物件，或任何其他的可迭代物件</p>
        <p>
          在 ES6 中的字串型態會遵守迭代規則，你可以撰寫一段類似下方的程式碼，將 hello 拆解為單獨的字元。
        </p>
        <pre><code class="language-js">
function* salute() {
  yield* 'hello'
} 
console.log([...salute()])
// ['h','e','l','l','o']
        </code></pre>
        <p>
          很自然的，你會使用[...'hello'] 作為另一種替代的方案。然而，當結合多個 yield 敘述時，我們會開始看到委派給另一個可迭代物件中的資料值。下一個範例顯示，將 salute 產生器修改為可傳入一個 name
          參數，並產生一個包含 'hello you' 字串的陣列。
        </p>
        <pre><code class="language-js">
function* salute(name) {
  yield* 'hello '
  yield* name
}
console.log([...salute('you' )])
//['h','e','l','l','o','', 'y', 'o', 'u']
        </code></pre>
        <p>
          再重申一次，你可以將 yield* 用於任何遵守迭代規則的資料型態，而不僅只是字串。這包含了產生器物件、陣列 arguments、瀏覽器中的 NodeList 節點串列、和任何有實作 Symbol.iterator
          的項目。下面的例子說明如何將 yield 和 yield* 結合運用，以使用產生器函式、可迭代物件、和展開算子描述一個序列中的資料。你可以推想出 console.log 敘述會輸出甚麼內容嗎？
        </p>
        <pre><code class="language-js">
const salute = {
  [Symbol.iterator](){
    const items = ['h','e','l','l','o']
      return {
        next:()=&gt; ({
            done: items.length === 0,
            value: items.shift()
        })
      }
  }
}
function* multiplied (base, multiplier) {
  yield base + 1 * multiplier
  yield base + 2 * multiplier
}
function* trailmix(){
  yield* salute
  yield 0
  yield* [1, 2]
  yield* [...multiplied(3, 2)]
  yield [...multiplied(6, 3)]
  yield* multiplied(15, 5)
}
console.log([...trailmix()])
        </code></pre>
        <p>
          以下是 trailmix 產生器函式產生的序列。
        </p>
        <pre><code class="language-js">
['h', 'e','l', 'l', 'o', 0, 1, 2, 5, 7, [9, 12], 20, 25]
        </code></pre>
        <p>
          除了以 for..of 和 Array.from 巡訪一個產生器物件之外，我們也可以直接使用產生器物件進行巡訪，接下來護我們看看如何進行。
        </p>
      </div>
      <h3 id="4-3-2">4-3-2 手動迭代產生器</h3>
      <p>
        產生器迭代操作不僅限於使用 for..of、 Array..from或 展開運算子。就像其他的可迭代物件,你可以使用它的 Symbol.iterator 於需要時以 .next 取出資料項,而不需使用嚴格同步迴圈
        for..of 、Array..from 或 展開運算子。若一個產生器物件是可迭代也是一個迭代器 : 你就不需要呼叫 g[Symbol.iterator]() 取得一個迭代器:你可以直接使用 g，因為它和
        Symbol.iterator 方法所回傳的物件是一樣的。
      </p>

      <p>
        以我們早前所建立的 numbers 迭代器為例、以下範例說明,你可以使用產生器物件和 while 迴圈手動操作巡訪。請記住,迭代器所回傳的物件都會有一個 done 特性，它會標示著序列是否已結束 ; 而 value
        特性則是目前序列資料項的值。
      </p>
      <pre><code class="language-js">
const g = numbers()
while (true) {
  const item = g.next()
  if (item.done) {
    break
  }
  console.log(item.value)
}   
      </code></pre>
      <p>
        使用送代器巡訪一個產生器,看起來像是用一種複雜的方式實作 for..of 迴圈;但樣的方式適合一些有趣的使用情境,例如: for..of 是一個同步迴圈 ; 反之,若使用迭代器則可以決定執行 g.next
        的時間點。這樣的優點是可以執行非同步的操作,並在取得結果後再呼叫 g.next。
        當呼叫產生器的 .next() 方法後,在取得結果值並回傳給 .next() 的當下，會有四種不同類型的「事件」可以暂停產生器的執行。我們接著就來瞭解以下四種情境:
      </p>
      <ul>
        <li>yield 運算回傳序列中的下一個值。</li>
        <li>return 敘述回傳序列中的最後一個值。</li>
        <li>throw 敘述完全中止產生器的執行。
        </li>
        <li>當函式不明確地回傳 undefine 值,表示已觸及産生器函式的結束訊息 { done: true }
        </li>
      </ul>
      <p>
        一旦産生器 g 結束了序列的巡訪,後續在呼叫 g.next() 就不會有任何效果,並且只回傳 { done:true}。 下面的程式碼說明
        在序列已訪問至結束端時,重複地呼叫 g.next ,我們可以觀察到等冪性 (idempotence,也就是重複執行均取得相同的結果)。
      </p>
      <pre><code class="language-js">
function* generator() {
  yield 'only'
}
  const g = generator()
  console.log(g.next())
  // {done: false, value: 'only'}
  console.log(g.next())
  // {done: true}
  console.log(g.next())
  // {done: true}
      </code></pre>
      <h3 id="4-3-3">4-3-3 於可迭代物件加入產生器</h3>
      <p>
        讓我們快速回顧一下產生器。當執行產生器函式時，它會回傳一個產生器物件。一個產生器物件具有一個next 方法，它會回傳序列中的下一個資料項目。next 方法會以 {value , done}
        的型態回傳物件。下面範例示範實作一個無限費氏數列產生器。我們先取得產生器物件的實例，並取得序列的前八個數值。
      </p>
      <pre><code class="language-js">
function* fibonacci(){
  let previous = 0 
  let current = 1
  while (true) {
    yield current
    const next = current + previous
    previous = current
    current = next
  }
}
const g = fibonacci()
console.log(g.next()) // { value: 1, done: false }
console.log(g.next()) // { value: 1, done: false }
console.1og(g.next()) // { value: 2, done: false }
console.log(g.next()) // { value: 3, done: false }
console.log(g.next()) // { value: 5, done: false }
console.log(g.next()) // { value: 8, done: false }
console.log(g.next()) // { value: 13, done: false }
console.log(g.next()) // { value: 21, done: false }
      </code></pre>
      <p>
        可迭代物件也具有類似的操作模式。他依循著回傳物件需附有 next 方法物件的協議，這個方法會以 { value , done }
        的型態回傳序列資料項目。下面的程式碼實作一個費氏數列可迭代物件,看起來很像我們方才所討論的產生器。
      </p>


      <pre><code class="language-js">
const fibonacci = {
  [Symbol.iterator]() {
  let previous = 0
  let current = 1
    return {
     next() {
     const value = current 
     const next = current + previous
     previous = current
     current = next
    }
    return { value, done: false }
    }
  }
}
const sequence = fibonacci[Symbol.iterator]()
console.log(sequence.next()) // { value: 1, done: false }
console.log(sequence.next()) // { value: 1, done: false }
console.log(sequence.next()) // { value: 2, done: false }
console.log(sequence.next()) // { value: 3, done: false }
console.log(sequence.next()) // { value: 5, done: false }
console.log(sequence.next()) // { value: 8, done: false }
console.log(sequence.next()) // { value: 13, done: false }
console.log(sequence.next()) // { value: 21, done: false }
        </code></pre>
      <p>
        再次強調,一個可迭代物件必須回傳一個附有 next 方法的物件:產生器函式也是一樣。next 方法回傳 { value , done } 型態的物件; 產生器函式也是一樣。如果我們將 fibonacci
        可迭代物件調整為將産生器函式結合 Symbol.iterator 特性，會變成如何呢? 事實證明這樣仍然是可行的。
      </p>
      <p>
        以下範例示範可迭代的 fibonacci 物件使產生器函式定義迭代的行為。請注意,可迭代物件的內容敘述與我們之前討論的 fibonacci 產生器函式均相同。我們可使用 yield、yield* ,
        那麼所有的產生器函式的敘述都可以完全保留。
      </p>
      <pre><code class="language-js">
const fibonacci = {
  [Symbol.iterator](){
    let previous = 0
    let current = 1
    while (true) {
        yield current
        const next = current + previous
        previous = current
        current = next
    }
  }
}
const g = fibonacci[Symbol.iterator]()
console.log(g.next ()) // { value: 1, done: false }
console.log(g.next ()) // { value: 1, done: false }
console.log(g.next()) // { value: 2, done: false }
console.log(g.next()) // { value: 3, done: false }
console.log(g.next()) // { value: 5, done: false }
console.log(g.next()) // { value: 8, done: false}
console.log(g.next()) // { value: 13, done: false }
console.log(g.next()) // { value: 21, done: false }
      </code></pre>
      <p>
        在此同時，可迭代協議也被一併保留。你可以使用 for..of 之類的方式，而不是手動地建立產生器物件，來確認這個特性。以下的範例使用 for..of 並導入一個迴圈中斷器，以避免無限迴圈的情況使應用程式崩潰。
      </p>
      <pre><code class="language-js">
for (const value of fibonacci) {
  console.log(value)
  if (value > 20) {
    break
  }
}
// 1
// 1
// 2
// 3
// 5
// 8
// 13
// 21
      </code></pre>
      <h3 id="4-3-4">
        4-3-4 利用產生器巡訪樹狀結構資料
      </h3>
      <p>
        運用於樹狀結構的巡訪演算法通常與遞迴相關，且難以理解。在下面的程式碼中，我們定義了一個 Node 類別，他可以保存著 value 值和任意數量的子節點。
      </p>
      <pre><code class="language-js">
class Node {
  constructor(value, ...children) {
    this.value = value
    this.children = children
  }
}
        </code></pre>

      <p>
        樹可以用深度優先搜尋(depth-first search) 進行巡訪 ,此搜尋會先訪問至樹狀結構最深處,此時就不會移動至節點串列的其他子節點。在以下的樹狀結構中、深度優先搜尋演算法會以
        1,2,3,4,5,6,7,8,9,10 的順序訪問樹的節點。
      </p>
      <pre><code class="language-js">
const root = new Node(1, 
  new Node(2),
  new Node(3,
    new Node(4,
      new Node(5,
        new Node(6)
      ),
      new Node(7)
    )
  ),
  new Node(8,
    new Node(9),
      new Node(10)
  )
)
      </code></pre>
      <p>
        深度優先巡訪可以使用產生器函式進行實作,它可以產生序列中每個節點的值,接著利用 yield* 運算子實作迭代器遞迴模組,遞迴訪問目前節點的子節點。
      </p>
      <pre><code class="language-js">
function* depthFirst(node) {
  yield node.value
  for (const child of node.children) {
    yield* depthFirst(child)
  }
}
console.log([...depthFirst(root)])
// [1,2,3,4,5,6,7,8,9,10]
      </code></pre>
      <p>
        在宣告巡訪演算法有些不同的地方,就是利用 depthFirst產生器，將 Node 類別更為可迭代。以下程式碼也受惠於此變更,讓 child 也是 Node 類別（因此也具備可迭代性）為了以 yield* 產生可迭代排序,讓
        child 節點可方便自其父節點的子節點序列取出。
      </p>

      <pre><code class="language-js">
class Node {
  constructor(value,...children) {
  this.value = value
  this.children = children
  }
  * [Symbol.iterator]() {
    yield this.value
    for (const child of this.children) {
      yield* child
    }
  }
}
console.log([...root])
//[1,2,3,4,5,6,7,8,9,10]
      </code></pre>
      <p>
        若我們想要變更為廣度優先搜尋 (breadth-first search ),可以將迭代器調整如下範例的敘述方式。此處,我們使用先進先出的佇列 (first-in first-out queue)
        作為尚未造訪的節點暫存區;在每次的迭代步驟，自根節點開始,我們會將目前的節點值印出,並將目前節點的子節點放入佇列中。子節點均自列的尾端加入,但自佇列的起始端取出;這意味著,樹狀結構的巡訪會先將該指定階層的節點均造訪完畢後,才會更深入至下一個階層。
      </p>
      <pre><code class="language-js">
class Node {
  constructor(value, ...children) {
    this.value = value
    this.children = children
  }
  * [Symbol.iterator]() {
    const queue = [this]
    while (queue.length) {
      const node = queue.shift()
      yield node.value
      queue.push(...node.children) 
    }
  }
}

console.log([...root])
// [1,2,3,8,4,9,10,5,7,6]
        </code></pre>
      <p>
        在迭代器協議允許自訂一個序列可按照我們需求執行迭代的情況下，產生器因為它具表達性的敘述,顯得非常方便使用。當樹結構有上千個節點,且迭代行為針對效能因素進行調校時,該都可以派上用場。
      </p>
      <h3 id="4-3-5">
        4-3-5 利用產生器函式增加彈性
      </h3>
      <p>
        目前為止,我們已經從序列建立的角度探討產生器的功能。產生器也可以作為一段程式碼的介面,此程式碼可決定産生器函式進行迭代的方式。
      </p>
      <p>
        本節,我們將撰寫可傳遞給方法的一個產生器函式，此方法會巡訪產生器以取得序列的所有資料項。即使初次看到這樣的撰寫方式,你可能會覺得這並非是標做法但大多數圍繞著產生器所建立的函式庫，,均會要求他們的使用者撰可由函式控迭代行為的產生器。
      </p>
      <p>
        下面的程式碼可作為一個範本,定義我們希望 modelProvider 運作的方式。使用者提供一個産生器函式,他每次可以產生出一個模組不同組件的細節，並取得與該組件相關的組件資訊。一個產生器物件可以將結果
        回傳給産生器函式,透過呼叫 g.next(result) 方法。當我們執行此敘述時, yield 敘述便會將産生器物件所提供的 result 結果進行運算。
      </p>
      <pre><code class="language-js">
modelProvider(function*() {
  const items = yield 'cart.items'
  const item = items.reduce((left, right) =&gt; left.price &gt; right.price ? left : right)
  const details = yield `products.${ item.id }`
  console.log(details)
})
  </code></pre>
      <p>
        無論何時當使用者自訂的產生器出產(yield)了一個值,產生器函式中的指令運作便會暂停,直到迭代器再次呼叫 g.next 才會恢復運行,但這可能會在幕後非同步地發生。下面的程式碼實作了一個 modelProvider 函
        式,它會迭代產生器所出産的 paths 。請注意我們如何將資廖傳遞給 g.next() 方法。
      </p>
      <pre><code class="language-js">
const model = {
  cart: {
    items: [item1, ..., itemN]
  },
  products: {
    product1:{...},
    productN:{...}
  }
}
function modelProvider(paths) {
  const g = paths()
  pull()
  function pull(data) {
    const { value, done } = g.next(data)
    if (done) {
      return
    }
    const crumbs = value.split('.')
    const data = crumbs.reduce(followCrumbs,model)
    pull(data)
  }
}

function followCrumbs(data, crumb) {
  if (!data || !data.hasOwnProperty(crumb)) {
    return null
  }
  return data[crumb]
}
          
  </code></pre>
      <p>
        要求使用者提供產生器函式的最大優點就是,函式配合yield 關鍵字的使用,當迭代器在兩個 g.next 呼叫之間執行非同步的操作時,程式碼的執行能夠有暂停運作的能力。
      </p>
      <h3 id="4-3-6">4-3-6 非同步流程的處理</h3>
      <p>
        回到前面討論的呼叫 modelProvider
        函式並傳入使用者提供的產生器的案例,如果模組的組件是非同步的方式提供,那麼程式應該要如何調整?使用產生器的優點是,若在巡訪路徑序列的動作變為非同步執行時,使用者自訂的函式則完全不需要變動。在擷取模組組件的情境中,我們已經能夠暫停產生器的執行;現在我們需要的就是可以詢問一個服務,該服務可以提供目前所需的路徑值,透過一個中繼的
        yield 敘述或其他的方式回傳;接著再呼叫產生器物件的 g.next。
      </p>
      <p>
        假設我們先返回到如下 modelProvider 的使用方式
      </p>
      <pre><code class="language-js">
modelProvider(function*() {
  const items = yield 'cart.items'
  const item = items.reduce(
  (left, right) =&gt; left.price &gt; right.price ? left :right)
  const details = yield  `products.${ item.id }`
  console.log(details)
})
  </code></pre>
      <pre><code class="language-js">
        </code></pre>
      <pre><code class="language-js">
        </code></pre>
      <pre><code class="language-js">
        </code></pre>
      <div class="border-block"></div>
    </section>
  </main>
</body>
<script src="./menu.js"></script>

</html>