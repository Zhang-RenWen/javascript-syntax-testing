<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>JavaScript-syntax-learning</title>
  <link rel="stylesheet" href="./hightlight/default.min.css" />
  <link rel="stylesheet" href=" https://necolas.github.io/normalize.css/8.0.1/normalize.css" />
  <link rel="stylesheet" href="./css/main.css" />
  <script src="./hightlight/hightlight.min.js"></script>
  <script>
    hljs.highlightAll();
  </script>
</head>

<body>
  <nav>
    <h1>現代 Javascript 實務應用</h1>
  </nav>
  <main>
    <aside></aside>
    <section>
      <h2>3-2 符號</h2>
      <p>
        符號在 ES6 中是一個新的基礎型別,是 JavaScript
        中的第七種資料型別。它是一個獨一無二的資料型別,如字串和數值一樣。符號並沒有字面上的表示法,例如:text.是字串,或1是數值。符號的目的主要
        是為了實作一些協議。舉例來說,迭代協議是使用符號去定義物件進行迭代的方法。
      </p>
      <p>
        以下會介绍三種符號類型,分別:區域符號,利用Symbol內建的封裝物件建立並藉由儲存其參考,或透過反射(reflection)
        進行存取;全域符號,利用 API 建立並可於程式碼間分享使用;以及「通用(well.
        known)」符號,內建於 JavaScript 中並可以用以定義內部的語言行為。
      </p>
      <h3 id="3-2-1">3-2-1 區域符號</h3>
      <p>
        符號可以利用 Symbol 封裝物件建立，在下面的程式中,我們建立一個名稱為
        first 的符號。 const first = Symbol() 你可以用 new 關鍵字於 Number 和
        String 但若用於Symbol 則會拋出
        TypeError的錯誤·這是為了避免一些錯誤和令人混淆的行為發生,例 如: new
        Number(3) !== Number(3)。以下的程式碼便會拋出錯誤訊息。 const oops =
      </p>
      <pre><code class="language-js">
new Symbol() // TypeError:Symbol不是一個建構子
        </code></pre>
      <p>為了方便除錯,你可以利用敘述句的方式建立符號。</p>
      <pre><code class="language-js">
const mystery = Symbol('my symbol')
</code></pre>
      <p>
        如數值和字串一樣，符號是不可改變的。然而,不像其他的資料型態，
        符號是具有唯一性的。如下面的程式範例,敘述句並不會影響它的唯一性。
        以相同的敘述句所建立的符號實際上並不相同,每個符號是獨一無二的。
      </p>
      <pre><code class="language-js">
console.log(Number(3) === Number(3)) // true
console.log(Symbol() === Symbol()) // false
console.log(Symbol('my symbol') === Symbol('my symbol')) // false
console.log(typeof Symbol()) // 'symbol'
console.log(typeof Symbol('my symbol')) // 'symbol'
</code></pre>
      <p>
        符號可以作為物件的特性鍵。注意,過去你使用運算取得的特性名稱簡
        化敘述的方法,利用符號只需要加入一個 weapon 符號鍵於 character 物
        件即可達成,如以下範例。為了存取一個符號特性,你會需要一個參考
        至符號的變數,並用以建立該特性。
      </p>
      <pre><code class="language-js">
  const weapon = Symbol('weapon')
  const character = {
    name: 'Penguin',
    [weapon]: 'umbrella'
  }
  console.log(character[weapon]) // 'umbrella'
</code></pre>
      <p>
        若使用傳統自物件取鍵的方式,是無法擷取到符號鍵的。下面範例呈現出,不管使用
        for..in、Object.keys、和 getOwnPropertyNames 都無法取得符號特性。
      </p>
      <pre><code class="language-js">
  for (let key in character) {
    console.log(key) // 'name'
  }
  console.log(Object.keys(character)) // ['name']
  console.log(Object.getownPropertyNames(character) // ['name']
</code></pre>
      <p>JSON 描述也會忽略 Symbol 特性</p>
      <pre><code class="language-js">
  console.log(JSON.stringify(character)) // '{"name" : "Penguin"}'
</code></pre>
      <p>實際上 Symbol 是可以被列舉，需要透過 Object.getownpropertysymbols</p>
      <pre><code class="language-js">
  console.log(Object.getOwnPropertySymbols(character)) // [Symbol(weapon) ]
</code></pre>
      <h3 id="3-2-2">3-2-2 符號的實際案例</h3>
      <p>
        符號的使用,可以透過一個函式庫將物件對應至 DOM 元件。例如:建立
        一個函式庫,它可以將日曆功能的 API 物件與指定的 DOM 元件連結起來 。在
        ES6 之前，並未有一個清楚的方式可以將 DOM 元件對應至物件 ;你僅能於 DOM
        元件中加入一個特性,並將它指向 API、但是這樣的 自訂特性會影響到原有的
        DOM 元件結構,故不是一個好的方法。特性
        鍵在使用上必須謹慎,需注意他不會被其他函式庫所使用,或甚至在未
        來也不能被語言本身所使用。就限制了你只能使用陣列查詢表 ( array lookup
        table ) 的方式，記錄著每一對 DOM/API 的配對資訊。然而，這
        樣的方式在大型的程式可能會較慢,因為陣列查詢表會隨著資料的增多
        而越來越大,造成查詢速度的緩慢。
        相反地,若使用符號,則不會發生此問題。它可以作為一種特性,且
        不會因為語言在未來所推出的新功能特徽造成程式毀壞,因為它具備
        唯一性。以下的程式碼顯示如何運用符號將 DOM 元件對應至日曆 API 物件。
      </p>
      <pre><code class="language-js">
const cache = Symbol('calendar')
function createCalendar(el) {
  if(cache in el){  //符號是否存在於元件中?
    return el[cache]  //使用 cache 避免重新初始化
  } 
  const api = el[cache] = {
    // 日曆 API 內容
  }
  return api
}
</code></pre>
      <p>
        這裡使用了一個 ES6 內建功能 一weakMap一 它可以將物件一對一對應至
        其他的物件,而不需要使用陣列。或透過物件的標的特性進行查找。
        比照起陣列查詢表， WeakMap 在執行查詢動作所花費的時間為常數，或
        O(1)。在第 5 章我們將會學習 WeakMap 和其他 ES6 的内建功能。
        <b>透過符號定義協議</b>
        稍早之前，我們曾說過符號的其中一個用途是運用於協議的定義。協議
        是一種溝通方式的規定,或定義行為規範。某些深奥的術語或規範需要
        描述定義時,函式庫可以利用符號,繼承函式庫中所定義的溝通規範，並提供給物件使用。
        參考以下範例程式碼,此處我們使用一個特別的 toJSON 方法·決定物件
        是否需用 JSON.stringify 進行資料序列化如你所見將 character 物 件進行
        stringify 操作，産生物件的序列化版本·並自 toJSON 方法 回傳。
      </p>
      <pre><code class="language-js">
  const character = {
    name: 'Thor',
    toJSON: () => ({
      key: 'value'
    })
  }
  console.log(JSON.stringify(character)) //  '"["key" : "value")"'
</code></pre>
      <p>
        相反地,如果 toJSON 不是一個函式,而是一個特性或有其他定義,那麼 這個
        character 物件便會進行序列化,包括 toJSON 特性,如下範例所
        示·這種不一致性的防護,需依賴標準的常規特性,才能夠正確定義反
        應的行為動作。
      </p>
      <pre><code class="language-js">
  const character = {
    name: 'Thor',
    toJSON: true
  }
  console.log(JSON.stringify(character) //  '"("name":"Thor" ,"toJSON": true]"'
</code></pre>
      <p>
        較好的方式是將 toJSON 以符號的方式進行實作，因為它不會受到其他的
        物件鍵值所影響。符號是具有唯一性的，無法被序列化，且唯有清楚明
        確地使用 Object.getOwnPropertySymbols ,才能夠使用它。因此，當需要
        牛鍵值所影響。符號是具有唯一性的,無法被序列化, 的方式是將 toJSON
        符號的方式進行實作,因為它不會受 要定義 JSON.stringify
        和物件序化的規則兩者間的互動規則時，這會
        是較佳的解決方案。参考以下使用符號實作 toJSON 的另一種替代方案，
        它將定義 stringify 函式的運作行為。
      </p>
      <pre><code class="language-js">
const json = Symbol('alternative to toJSON')
const character = {
  name: 'Thor',
  [json]:()=> ({
  key:'value'
  })
}
stringify(character)
function stringify(target) {
  if (json in target) {
    return JSON,stringify(target[json]())
  } 
  return JSON.stringify(target)
}
        </code></pre>
      <p>
        使用符號意謂著,我們會需要利用運算取得的特性名稱,以直接在一
        個物件實字中定義 json 的行為。這也表示此行為將不能夠與其他自訂
        的特性,或未來各種無法預知的語言新功能特徵產生衝突。另一個特點是,符號
        json 仍可提供給 stringify 函式的操作者使用,如此就可
        以自訂其行為。只要簡單地加上以下一行程式敘述,便可將 json 符號透過
        stringify 函式提供使用。如此當符號變更其行為時,也能夠與 stringify
        函式同步變更。 stringify.as = json
      </p>
      <p>
        藉著提供 stringify 函式使用 stringify.as 符號便也可以提供使用，
        允許操作者利用自訂的符號微調物件,達成調整行為定義的目的。
        當談及以符號描述行為,相較於額外傳遞一個參數至 stringify 函式，
        其優點在於,第一:額外加入一個函式參數影響 API 已公開運用的方式
        ,若是於函式內部支援符號的行為定義,便不會影響公開 API 已公開的運用
        options 物 件為每一個選項定義不同的特性,也可以降低對 API 的影響幅度，
        但並不是每一個函式呼叫的情境都適合使用 options 物件。
        運用符號定義行為的好處,就是當加強自訂物件的行為時,不會影響或
        變更其他程式碼或邏輯,除了定義符號特性內容值。透過函式內部程式
        碼的實作改善來優化行為定義。另一個好處是,當新的語言功能推出
        時,也不會因為無法預期的名稱衝突影響程式運作。
        除了區域符號外，還有全域符號註冊，使跨越程式範圍存取使用成為可能。
      </p>
      <h3 id="3-2-3">3-2-3 全域符號註冊表</h3>
      <p>
        程式領域(code realm)的定義,就是任何 JavaScript 的執行環境,例
        如：應用程式所執行的頁面、頁面裡的&lt;iframe&gt;、透過 eval
        執行的程式碼、 或是任何類型的背景程式工作員(workers)一如:網頁背景程式
        工作員、服務工作員或共用程式工作員等。每一个執行環境都有屬於它
        的全域物件。舉例說,定義於頁面 window 物件中的全域變數就無法被
        ServiceWorker 服務工作員所用。相反地,若透過全域符號註冊
        的機制,就能夠在所有的程式領域中分享,共同使用。
        介紹兩種方法，可與執行期間範圍的全域符號註冊表進行互動： Symbol.for
        和Symbol.keyFor
      </p>
      <h3>運用 Symbol.for(key) 取得符號</h3>
      <p>
        Symbol.for(key) 方法能夠利用 key 符號鍵於執行期間範圍( runtime-wide )
        的全域符號註冊表中進行查詢。如果 key
        符號鍵所對應的符號存在於全域符號註冊表中， 便會回傳該符號;反之,若 key
        符號鍵不存在對應符號 ,則會新建一個符號並加入至符號註冊表中與之對應。
        相當於 Symbol.for(key) 是等幂的(idempotent):他依據所提供的 key
        符號鍵搜尋對應的符號,如果該符號不存在,則建立一個新的符號,
        並將該符號回傳。 在以下的程式碼中,第一句敘呼叫 Symbol.for 建立一個符,
        'example 作為識別名稱,將加入至註冊表中並回傳。第二句敘也
        會回傳相同的符,因為ke符鍵已經存在註冊表中一並且與第一
        句敘述所回傳的符號相連結。
      </p>
      <pre><code class="language-js">
const example = Symbol.for('example')
console.log(example === Symbol.for('example')) // true
        </code></pre>
      <p>
        全域符號註冊表藉由 key 符號鍵來掌握符號。值得注意的是,
        當建立符號並加入至註冊表時 key 鍵也可以被作為一種 description，
        也就是符號的描述。考量這些符號於執行期間階段都具備全域有效範，
        你可能會於符號的鍵值加入字首(prefix),作為你所使用的函式庫或元件
        的辨識名稱,減少可能發生的名稱衝突。
      </p>
      <h3>運用Symbol.keyFor(symbol)擷取符號鍵</h3>
      <p>
        若給定一個符號 symbol,Symbol.keyfor(symbol) 會回傳該符號於
        全域符號註冊表中相對應的 key 符號鍵。下面範例顯示我們如何利用
        Symbol.keyfor 擷取一個 symbol 符號的 key 符號鍵。
      </p>
      <pre><code class="language-js">
const example = Symbol.for('example')
console.log(Symbol.keyFor(example)) // 'example'
  </code></pre>
      <p>
        請注意,如果符號並不存在於全域符號註冊表中,那麼此方法便會回傳 undefined
        .
      </p>
      <pre><code class="language-js">
    console.log(Symbol.keyFor(Symbol())) // undefined
  </code></pre>
      <p>
        須謹記在心的是,欲於全域符註冊表中使用區域符號找到對應的符號
        鍵,這是不可能發生的,即使他們具有相同的描述,因為區域符並不
        屬於全域符號註冊表的一部分。可參考以下範例程式碼。
      </p>
      <pre><code class="language-js">
const example = Symbol.for('example')
console.log(Symbol.keyFor(Symbol('example'))) // undefined
  </code></pre>
      <p>
        至此你已經瞭解如何與全域符號註冊表進行互動的 API 了,接下來我們
        會討論一些使用上需考量的因素。
      </p>
      <h3>最佳實務案例與考量因子</h3>
      <p>
        執行期間範圍的註冊表意味著符號的存取使用可跨越程式領域。全域註冊表
        在所有的程式領域中,相同的物件都會回傳一樣的參考。在以下範例中 ,說明
        Symbol.for 的 API 如何在一個頁面和一個 &lt;iframe&gt;
        框架中,均回傳相同的符號。
      </p>
      <pre><code class="language-js">
const d = document
const frame = d.body.appendChild(d.createElement('iframe'))
const framed = frame.contentWindow
const s1 = window.Symbol.for('example')
const s2 = framed.Symbol.for('example')
console.log(s1 === s2) // true
        </code></pre>
      <p>
        廣泛地運用符號,需要一些取捨。也就說、函式庫能夠簡單地將它
        們所使用的符號提供使用;但相對地,它也可能會在 API 介面中,將區
        域符號暴露於外界。當符號必須跨越兩個程式碼間分享使用時,使用符
        號註冊表是明顯有效的。例如:於 ServiceWorker 服務工作員和一個網
        頁。當你不想為儲存符號和參考困擾時,使用 API 也是非常便利的。你
        可以直接使用註冊表,因為若提供予相同的 key 符號鍵,是可以保證取 得相同的
        Symbol 符·請記得,這些符號於執行階段是可分享的;但是
        如果你使用一些廣泛使用的符號名稱,如 each 或 contains,可能會導
        致一些非預期的結果發生。 接下來還有另一種符號要介紹:內建的通用符號。
      </p>
      <h3 id="3-2-4">3-2-4 通用符號</h3>
      <p>
        到目前為止,我們已經含括了兩種符號建立的方式;以 Symbol 函式建立
        的符號,和利用 Symbol.for 所建立的符號。第三種也是最後一種符號,
        稱為通用符號。這是内建於語言之中,而非由 JavaScript 開發人員所建
        立;並且它可與內部語言的行為掛鉤,讓你可延伸或自訂語言的各層 面,這在 ES6
        之前是無法達成的。
      </p>
      <p>
        以下是一個非常好的範例,說明如何利用 Symbol.toPrimitive 通用符
        號,將語言功能延伸且不需要破壞既有的程式碼·它可以指定給一個
        函式,使函式可以決定如何將物件轉換為一個基礎型別的值·函式會
        接收一個名稱為 hint 的参數,内容值可以是 'string'、'number'、或
        'default',指示出期望取得的值所隸屬的基礎型别。
      </p>
      <pre><code class="language-js">

  const morphling = {
    [Symbol.toprimitive](hint) {
      if (hint === 'number') {
        return Infinity
      }
    
      if (hint === 'string') {
        return 'a lot'
      }

      return '[object Morphling]'
    }
  }
  console.log(+morphling) 
  //  Infinity 

  console.log(`That is ${morphling}!`)
  //  'That is a lot!' 

  console.log(morphling + ' is powerful')
  //  '[object.Morphling] is powerful'

</code></pre>
      <p>
        另一個通用符號的範例是 Symbol.match。將 Symbol.match 設定為 false
        的正規運算式,會被視為一個字串,以配合.startsWith、.endsWith 與
        .includes 使用。這三個函式是 ES6 中新的字串方法。第一個方法
        .startswith 方法可用於判斷字串是否以所指定的字串起始;第二個方法
        .endsWith 方法可判斷字串是否以所指定的字串結束;第三種 .include
        方法可判斷字串起是否包含所指定的字串,若有則回傳 true 。下面的範例說明
        Symbol.match 如何用於將字串正規運算式所 描述的字串進行比較。
      </p>
      <pre><code class="language-js">
  const text = '/an example string/'
  const regex = /an example string/
  regex[Symbol.match] = false
  console.log(text.startsWith(regex))
  //  true
</code></pre>
      <p>
        若未透過符號變更正規運算式,那麼程式便無法正確運作,因為 startswith
        方法需要傳入的是一個字串,而非一個正規運算式。
      </p>
      <h3>不透過註冊表於程式領域進行分享</h3>
      <p>
        通用符號可於程式領域間分享使用,透過以下範例可瞭解, Symbol.iterator
        的參考與 &lt;iframe&gt; 視窗中所取得的參考相同。
      </p>
      <pre><code class="language-js">
  const frame = document.createElement('iframe')
  document.body.appendChild(frame)
  Symbol.iterator === frame.contentWindow.Symbol.iterator //  true
</code></pre>
      <p>
        請注意,即使通用符可於程式領域分享使用,但它們並不存在於全域註冊表中。
        下面程式碼說明,當我們欲在註冊表中擷取該符號的 key 鍵時 ,
        Symbol.iterator 會産生 undefined 的結果,這表示符號並不存在於
        全域註冊表中。
      </p>
      <pre><code class="language-js">
  console.log(Symbol.keyFor(Symbol.iterator)) //  undefined
</code></pre>
      <p>
        Symbol.iterator 也是一個非常好用的通用符號,在一些其他的語言中
        它都被作為依序迭代的工具;可利用函式定義其行為,並指定予物件
        中以符號所定義的特性。在下一節的內容,我們會進一步討 Symbol. iterator
        的操作細節,並廣泛地將它與迭代器和迭代協議搭配使用。
      </p>
    </section>
  </main>
</body>
<script src="./menu.js"></script>

</html>