<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="./public/favicon.ico" />
    <meta http-equiv="cache-control" content="no-cache" />
    <title></title>
    <link rel="stylesheet" href=" https://necolas.github.io/normalize.css/8.0.1/normalize.css" />
    <link rel="stylesheet" href="./hightlight/default.min.css" />
    <link rel="stylesheet" href="./css/main.css" />
    <link rel="stylesheet" href="./css/copybutton.css" />
    <link rel="stylesheet" href="./css/hightlight.css" />
    <script src="./hightlight/hightlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BEVZJDBC7Z"></script>
    <script src="./js/gtag.js"></script>
  </head>

  <body>
    <header>
      <nav>
        <h1>
          <span id="toggle-menu"></span>
          <a href="index.html"></a>
        </h1>
      </nav>
    </header>
    <main>
      <aside>
        <nav></nav>
      </aside>
      <article>
        <h2 id="1-9-1">1-9-1 資料結構</h2>
        <p>
          資料結構是電腦中組織和儲存資料的特定方式,目的是方便且高效率地對資料進行存取和修改。一方面,資料結構表述了資料之間的關係,以及操作資料的一系列方法,資料又是程式的基本單元,因此無論是哪種語言、哪個領域,都離不開資料結構:另一方面,資料結構是演算法的基礎,其本身包含了演算法的部分內容。也就是說,想要掌握演算法,先有一個牢固的資料結構基礎是必要條件。
        </p>
        <p>
          前端領域也到處表現資料結構的應用,尤其是隨需求的複雜度上升,前端工程師越來越離不開資料結構。React、Vue
          些設計的架構,上線文件編輯系統、大型管理系統,甚至一個簡單的檢索需求,都離不開資料結構的支援。是否掌握了這個困難是進階的重要考量。
        </p>
        <p>資料結構分為以下8大類。</p>
        <ul>
          <li>陣列:Array</li>
          <li>堆疊:Stack</li>
          <li>佇列:Queue</li>
          <li>結串列:LinkedList</li>
          <li>樹:Tree</li>
          <li>圖:Graph</li>
          <li>字典樹:Trie</li>
          <li>雜湊表(雜湊表):Hash Table</li>
        </ul>
        <h3>堆疊和佇列</h3>
        <p>
          堆疊和佇列是一種操作受限的線性結構,它們非常簡單,雖然 JavaScript
          並沒有原生內建這樣的資料結構,但是可以輕鬆地將它們模擬出來。
        </p>
        <p>堆疊的實現遵循後進先出(Last,First Out LIFO) 原則,範例程式如下：</p>
        <pre><code class="language-js">
class Stack {
  constructor(...args) {
    this.stack = {...args}
  }
  // Modifiers
  push(...items) {
    return this.stack.push(... items)
  }
  pop() {
    return this.stack.pop()
  }
  peek() {
    // Element access
    return this.isEmpty()
    ? undefined
    : this.stack[this. size () - 1]
  }
  // Capacity
  isEmpty() {
    return this.size() == 0
  }
  size() {
    return this.stack.length
  }
}
        </code></pre>
        <p>佇列的實現遵循先進先出(First in, First out FIFO )原則,範例程式如下：</p>
        <pre><code class="language-js">
class Queue {
  constructor(. ..args) {
    this.queue = [...args]
  }
  // Modifiers
  enqueue(...items) {
    return this.queue.push(... items)
  }
  dequeue () {
    return this.queue.shift()
  }
  // Element access 
  front() {
    return this.isEmpty()
    ? undefined
    : this.queue[0]
  }
  back () {
    return this.isEmpty()
    ? undefined
    : this.queue[this.size() - 1]
  }
  // Capacity
  isEmpty() {
    return this.size() == 0
  }
  size() {
    return this.queue.length
  }
}
        </code></pre>
        <p>堆疊和佇列的實際應用場景比比皆是,例如下面這些。</p>
        <ul>
          <li>瀏覽器的歷史記錄,因為回復總是回復到上一個最近的頁面,所以它需要遵循堆疊的原則。</li>
          <li>與瀏覽器的歷史記錄類似,任何 undo/redo 都是以堆疊為基礎的實現。</li>
          <li>在程式中,廣泛應用遞迴產生的呼叫堆疊同樣也是堆疊思想的表現。</li>
          <li>同上,瀏覽器在拋出例外時,通常都會拋出呼叫堆疊資訊。</li>
          <li>在電腦科學領域中的應用也比較廣泛,如進位轉換、括號比對、堆疊混洗、運算式求值等。</li>
          <li>
            佇列的應用更為直觀,所謂的巨任務/微任務都是佇列, 不管是什麼類型的任務,都是先進先執行。
          </li>
          <li>
            在後端中的應用也比較廣泛,如訊息佇列(RabbitMQ、ActiveMQ
            等)，這種佇列能造成延遲緩衝的功效。
          </li>
        </ul>
        <p>
          總結以上，不管是堆疊還是佇列,都是用陣列來模擬的。陣列是最基本的資料結構,但是它的價值是驚人的。這裡稍微提一下,React
          中 hook 從本質上看可以簡單地被看作陣列。
        </p>
        <h3>鏈結串列</h3>
        <p>
          堆疊和佇列都可以用陣列實現,鏈結串列同樣和陣列一樣,都是按照一定的順序儲存元素的,不同的地方在於鏈結串列不能像陣列一樣透過索引對元素進行存取,而是透過每個元素指向其下一個元素的方式進行存取。
        </p>
        <p>
          直觀上可得出這樣一個結論:鏈結串列不需要一段連續的儲存空間,「指向下一個元素」的方式能夠更大限度地利用記憶體。
        </p>
        <p>根據以上結論可以繼續歸納出鏈結串列的優點,如下。</p>
        <ul>
          <li>鏈結串列的插入和刪除操作的時間複雜度是常數級的,只需要改變相關節點的指標指向即可。</li>
          <li>鏈結串列可以像陣列一樣循序存取元素，尋找元素的時間複雜度是線性的。</li>
        </ul>
        <p>下面來看一看鏈結串列的應用場景。</p>
        <p>
          React 的核心演算法 Fiber 就是透過串列實現的。 React 最早使用堆疊協調(stack
          reconciler)排程演算法。堆疊協調排程演算法最大的問題在於它是像函數呼叫堆疊一樣,遞迴地自頂向下地進行
          diff 和 render
          相關操作的,在堆疊協調排程演算法執行的過程中,該排程演算法始終佔據瀏覽器主執行緒。也就是說在此期間,使用者的互動所觸發的版面配置行為、動畫執行任務都不會被立即回應,進一步影響使用者體驗。
        </p>
        <p>
          因此,React Fiber 將繪製更新過程進行了拆解,簡單說,就是每次檢查虛擬 DOM
          的一小部分,在檢查間隙會檢查是否還有時間繼續執行下一個虛擬 DOM
          樹上的某個分支任務,同時觀察是否有更優先的任務需要回應,如果沒有時間執行下一個虛擬 DOM
          上的某個分支任務,有更高優先順序的任務,React
          就會讓出主執行緒,直到主執行緒不忙的時候繼續執行那個分支任務。
        </p>
        <p>
          所以,React
          Fiber其實很簡單,將堆疊協調過程分成區塊,一次執行一區塊,執行完一區塊之後需要將結果儲存起來,根據是否還有空閒的回應時間
          (requestIdleCallback)來決定下一步策略。當所有的區塊都已經執行完畢後,就進入提交階段,這個階段需要更新
          DOM,整個過程是一口氣同步完成的。
        </p>
        <p>
          React Fiber 是專門用於 React
          元件堆疊呼叫的重新實現,可以隨意中斷呼叫堆疊並手動操作呼叫堆疊,也就是說一個 Fiber
          就是一個虛擬堆疊幀,其結構如下所示。
        </p>
        <pre><code class="language-js">
function FiberNode(
  tag: WorkTag,
  pendingProps: mixed,
  key: null | string,
  mode: TypeOfMode,
){
  // Instance
  // ...
  this.tag = tag;
  // Fiber
  this.return = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;

  this.ref = null;

  this pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;
  this.dependencies = null;
  // Effects
  // ...
  this.alternate = null;
}
        </code></pre>
        <p>
          這麼看,Fiber 就是一個物件,透過 parent、children、sibling, 同時,parent、children、sibling
          又都是 Fiber 結構,FiberNode.alternate 這個屬性用來儲存上一次繪製的結果,事實上整個 Fiber
          模式就是一個鏈結串列。React
          也借此從依賴於內建堆疊同步遞迴模型,變為具有鏈結串列和指標的非同步模型了。
        </p>
        <p>實際的繪製過程如下。</p>
        <pre><code class="language-js">
function renderNode(node) {
  // 判斷是否需要繪製該節點,如果 props 發生變化,則呼叫 render
  if (node.memoizedProps !== node.pendingProps) {
    render(node)
  }
  // 是否有子節點,如果有則進行子節點繪
  if (node.child !== null) {
    return node.child
    // 是否有兄弟節點,如果有則進行兄弟節點繪製
  } else if (node.sibling !== null){
    return node.sibling
    // 沒有子節點和兄弟節點
  }else if (node.return !== null){
    return node. return
  } else {
    return null
  }
}

function workloop(root) {
  nextNode = root
  while (nextNode !== null && (no other high priority task)) {
    nextNode = renderNode (nextNode)
  }
}
        </code></pre>
        <p>
          注意,在 workloop 中, while 的條件是 nextNode!==null &&(no other high priority
          task)，這是描述 Fiber
          工作原理的關鍵虛擬程式碼。以上只是簡略的虛體程式碼用於說明鏈接串列的資料結構，並沒有介紹
          requestAnimationFame(callback)和 requestIdleCallback(callback)
          的實現，這裏重點是體會鏈結串列資料結構的思想。
        </p>
        <h3>鏈結串列實現</h3>
        <p>實現鏈結串列首先串進行分類,常見的有單向鏈接串列和雙向鏈結串列。</p>
        <p>有了節點類別,下面來初步實現雙向鏈結串列類別</p>
        <ul>
          <li>
            單向鏈結串列:單向鏈結串列是維護一系列節點的資料結構,其特點是每個節點都包含資料,同時包含指向鏈結串列中下一個節點的指標。
          </li>
          <li>
            雙向鏈結串列:與單向鏈結串列不同,雙向鏈結串列的特點是每個節點除了包含其資料,還包含分別指向其前驅節點和後繼節點的指標。
          </li>
        </ul>
        <p>(單向案例要另外找)</p>
        <p>根據雙向鏈結串列的特點,實現一個節點建構函數(節點類別)的程式如下。</p>
        <pre><code class="language-js">
  class DoublyLinkedList {
    constructor() {
      // 雙向鏈結串列的開頭
      this.head = null
      // 雙向鏈結串列的結尾
      this.tail = null
    }
  // ...
  }
        </code></pre>
        <p>接下來,需要實現雙向鏈結串列原型中的一些方法,這些方法包含以下幾種。</p>
        <ul>
          <li>add:在鏈結串列尾部增加一個新的節點。</li>
          <li>addAt:在鏈結串列指定位置增加一個新的節點。</li>
          <li>remove:刪除鏈結串列指定資料項目節點。</li>
          <li>removeAt:刪除鏈結串列指定位置節點。</li>
          <li>reverse:翻轉鏈結串列。</li>
          <li>swap:交換兩個節點資料。</li>
          <li>isEmpty:查詢鏈結串列是否為空。</li>
          <li>length:查詢鏈結串列長度。</li>
          <li>traverse:檢查鏈結串列。</li>
          <li>find:尋找某個節點的索引。</li>
        </ul>
        <p>來逐一實現鏈結串列的各種方法，add方法的程式如下。</p>
        <pre><code class="language-js">
add(item) {
  // 產生實體一個節點
  let node = new Node(item)

  // 如果目前鏈結串列還沒有頭
  if(!this.head) {
    this.head = node
    this.tail = node
  }
  //如果目前鏈結串列已經有了頭,則只需要在尾部加上該節點
  else {
    node.prev = this.tail
    this.tail.next = node
    this.tail = node
  }
}
        </code></pre>
        <p>addAt 方法的程式如下。</p>
        <pre><code class="language-js">
addAt(index, item) {
  let current = this.head

  let counter = 1
  let node = new Node(item)

  //如果在頭部插入
  if (index === 0) {
    this.head.prev = node
    node.next = this.head
    this.head = node
  }
  //如果在非頭部插入,則需要從頭開始找尋插入位置
  else {
    while(current) {
      current = current.next
      if( counter === index) {
        node.prev = current.prev
        current.prev.next = node
        node.next = current
        current.prev = node
      }
      counter++
    }
  }
}
        </code></pre>
        <p>remove 方法的程式如下。</p>
        <pre><code class="language-js">
remove(item) {
  let current = this.head
  while (current) {
    //找到了目標節點
    if (current.data === item ) {
      //目標鏈結串列只有目前目標項,即目標節點既是鏈結串列頭又是鏈結串列尾
      if (current == this.head && current == this.tail) {
        this.head = null
        this.tail = null
      }
      //目標節點為鏈結串列頭
      else if (current == this.head ) {
        this.head = this.head.next
        this.head.prev = null
      }
      //目標節點為鏈結串列尾
      else if (current == this.tail ) {
        this.tail = this.tail.prev;
        this.tail.next = null;
      }
      //目標節點在鏈結串列首尾之間,即中部
      else {
        current.prev.next = current.next;
        current.next.prev = current.prev;
      }
    }
    current = current.next
  }
}
        </code></pre>
        <p>removeAt方法的程式如下。</p>
        <pre><code class="language-js">
removeAt (index) {
  // 都是從頭開始檢查
  let current = this.head
  let counter = 1

  //删除鏈結串列頭部
  if (index === 0 ) {
    this.head = this.head.next
    this.head.prev = null
  }
  else {
    while(current) {
      current = current.next
      //如果目標節點在鏈結串列尾部
      if (current == this.tail) {
        this.tail = this.tail.prev
        this.tail.next = null
      }
      else if (counter === index) {
        current.prev.next = current.next
        current.next.prev = current.prev
        break
      }
      counter++
    }
  }
}
        </code></pre>
        <p>reverse 方法的程式如下。</p>
        <pre><code class="language-js">
reverse() {
  let current = this.head
  let prev = null
  while (current) {
    let next = current.next
    //前後倒置
    current.next = prev
    current.prev = next
    prev = current
    current = next
  }
  this.tail = this.head
  this.head = prev
}
        </code></pre>
        <p>swap方法(用於交換兩個節點的資料值)的程式如下。</p>
        <pre><code class="language-js">
swap(index1, index2) {
  // 使 index1 始終小於 index2 ,方便後面尋找交換
  if (index1 > index2) {
    return this.swap(index2, index1)
  }
  let current = this.head
  let counter = 0
  let firstNode
  
  while(current !== null) {
    // 找到第一個節點,並儲存起來
    if (counter === index1 ){
      firstNode = current
    }
    //找到第二個節點,並進行資料交換
    else if (counter === index2) {
      // ES 提供了更簡潔的交換資料的方法,這裡用傳統方式實現更為直觀
      let temp = current.data
      current.data = firstNode.data
      firstNode.data = temp
    }
    current = current.next
    counter++
  }
  return true
}
        </code></pre>
        <p>isEmpty 方法的程式如下。</p>
        <pre><code class="language-js">
isEmpty () {
  return this.length() &lt; 1
}
        </code></pre>
        <p>isEmpty 方法使用了 length 方法實現，length 方法的程式如下。</p>
        <pre><code class="language-js">
length() {
  let current = this.head
  let counter = 0
  while(current !== null) {
    counter++
    current = current.next
  }
  return current
}
        </code></pre>
        <p>length 方法透過檢查結串列傳回鏈結串列長度。</p>
        <p>traverse 方法的程式如下。</p>
        <pre><code class="language-js">
traverse (fn) {
  let current = this.head
  while(current !== null) {
    fn(current)
    current = current.next
  }
  return true
}
        </code></pre>
        <p>
          有了上面 length 方法的檢查實現， traverse 方法也就不難了解了，它接收一個檢查執行函數,在
          while 循環中進行呼叫。
        </p>
        <p>最後，search方法的程式如下。</p>
        <pre><code class="language-js">
search(item) {
  let current = this.head
  let counter = 0
  while( current ) {
    if( current.data == item ) {
      return counter
    }
    current = current.next
    counter++
  }
  return false
}
        </code></pre>
        <p>
          至此就實現了所有 DoublyLinkedList
          類別向鏈結串列的方法。仔細分析一下整個實現過程可以發現,雙向鏈結串列的實現並不複雜,在手寫過程中需要開發者做到「心中有表」,考慮到目前節點的
          next 和 prev 設定值,其在邏輯實現上還是很簡單的。
        </p>
        <p>
          掌握了這些內容,再回想一下鏈結串列的應用,以及 React Fiber
          的設計和實現,也許一切就都變得不再神秘。
        </p>
        <h3>樹</h3>
        <p>
          不同於之前介紹，樹是非線性的。因為樹決定了其儲存的資料有明確的層級關係，因此對於維護具有層級特性的資料,樹是一個天然良好的選擇。
        </p>
        <p>前面提到,樹有很多種分類,但是它們都具有以下特性。</p>
        <ul>
          <li>除了根節點,所有的節點都有一個父節點。</li>
          <li>每一個節點都可以有許多個子節點,如果沒有子節點,那麼就稱此節點為葉子節點。</li>
          <li>一個節點所擁有的葉子節點的個數被稱為該節的度,因此葉子節點的度為0。</li>
          <li>在所有節點中,最大的度為整棵樹的度。</li>
          <li>樹的最大層次被稱為樹的深度。</li>
        </ul>
        <p>
          從應用上來看,前端開中的DOM 就是樹狀結構;同理,不管 是React 還是 Vue 的虛擬 DOM 也都是樹。
        </p>
        <h4>二元搜尋樹的實現和檢查</h4>
        <p>
          二元樹是最基本的樹,因為它的結構最簡單,每個節點最多包含兩個子節點。二元樹又非常有用,因為根據二元樹可以延伸出二元搜尋樹(BST)、平衡二元搜尋樹(AVL)、紅黑樹(R/BTree)等。
        </p>
        <p>二元搜尋樹有以下特性。</p>
        <ul>
          <li>左子樹上所有節點的值均小於或等於它的根節點的值。</li>
          <li>右子樹上所有節點的值均大於或等於它的根節點的值。</li>
          <li>左、右子樹也分別為二元搜尋樹。</li>
        </ul>
        <p>根據其特性實現二元搜尋樹時，應該先建置一個節點類別,如下所示。</p>
        <pre><code class="language-js">
class Node{
  constructor(data) {
    this.left = null
    this.right = null
    this.value = data
  }
}
        </code></pre>
        <p>接著,按照慣例實現二元搜尋樹的以下方法。</p>
        <ul>
          <li>insertNode:根據一個父節點插入一個子節點。</li>
          <li>insert:插入一個新節點。</li>
          <li>removeNode:根據一個父節移除一個子節點。</li>
          <li>remove:移除一個節點。</li>
          <li>findMinNode:取得子節點的最小值。</li>
          <li>searchNode:根據一個節點找子節點。</li>
          <li>search:尋找節點。</li>
          <li>preOrder:前序検查。</li>
          <li>InOrder:中序檢查。</li>
          <li>PostOrder:後續檢查。</li>
        </ul>
        <p>下面來實現樹結構的各種方法，insertNode 和 insert 方法的程式如下。</p>
        <pre><code class="language-js">
insertNode (root, newNode) {
  if (newNode.value &lt; root.value) {
    (root.left) ? root.left= newNode : this.insertNode(root.left,newNode)
  } else {
    (!root.right) ? root.right =newNode : this.insertNode(root.right,newNode)
  }
}
insert (value) {
  let newNode = new Node(value)
  if (!this.root) {
    this.root = newNode
  } else {
    this.insertNode(this.root, newNode)
  }
}
        </code></pre>
        <p>
          insertNode方法先判斷目標父的值,如果插入節點的值更小,則放到父節點的左邊,接著遞迴呼this.insertNode(root.left,newNode);
          如果插入節點的值更大,則放到父節點的右邊。
        </p>
        <p>insert 方法中多了建置 Node 節點實例這一步,而 removeNode 和 remove 方法 的程式如下。</p>
        <pre><code class="language-js">
removeNode(root, value) {
  if(!root) {
    return null
  }
  if (value &lt; root.value) {
    root.left = this.removeNode(root.left, value)
    return root
  } else if (value > root.value) {
    root.right = tis.removeNode(root.right, value)
    return root
  } else {
    //找到需要刪除的節點
    //如果目前 root 節點無左右子節點
    if (!root.left && !root.right) {
      root = null
      return root
    }
    // 只有左節點
    if (root.left && !root.right) {
      root = root.left
      return root
    }
    // 只有右節點
    else if (root,right) {
      root = root.right
      return root
    }
    // 有左右兩個子節點
    let minRight = this.findMinNode(root.right)
    root.value = minRight.value
    root.right = this.removeNode(root.right, minRight.value)
    return root
  }
}
remove (value) {
  if (this.root) {
    this.removeNode(this.root, value)
  }
}
        </code></pre>
        <p>上述程式可能最需要思考的就是要刪除的節點含有左右兩個子節點的情況。</p>
        <p>
          當需要刪除的節點(目標節點)含有左右兩個子節點時,因為要把目前節點刪除,所以就需要找到合適的補位節點,這個補位節點一定在該目標節點的右側樹中,因為這樣才能確保補位節點的值一定大於該目標節點的左側樹所有節點的值,而該目標節點的左側樹不需要調整;同時,為了確保補位節點的值一定要小於該目標節點的右側樹節點的值,要找到的補位節點應該是該目標節點的右側樹中值最小的那個節點。下面借助
          this.fndMinNode 方法實現這個過程。
        </p>
        <pre><code class="language-js">
findMinNode (root) {
  if (!root.left) {
    return root
  } else {
    return this.findMinNode(root.left)
  }
}
        </code></pre>
        <p>該方法會不斷進行遞迴,直到找到最左側的葉子節點。</p>
        <p>尋找節點的方法(searchNode 和 search) 的實現程式如下。</p>
        <pre><code class="language-js">
searchNode(root, value) {
  if (!root) {
    return null
  }
  if (value < root.value) {
    return this.searchNode(root.left, value)
  }else if (value > root.value) {
    return this.searchNode(root.right, value)
  }
  return root
}
search(value) {
  if (!this.root) {
    return false
  }
  return Boolean(this.searchNode(this.root, value))
}
        </code></pre>
        <p>前序檢查程式如下。</p>
        <pre><code class="language-js">
preOrder(root) {
  if (root) {
    console.log(root.value)
    this.preOrder(root.left)
    this.preOrder(root.right)
  }
}
        </code></pre>
        <p>中序檢查的範例程式如下。</p>
        <pre><code class="language-js">
inOrder(root) {
  if (root) {
    this.inOrder(root.left)
    console,log(root.value)
    this.inOrder(root.right)
  }
}
        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
      </article>
    </main>
  </body>
  <script type="module" src="./js/main.js"></script>
</html>
