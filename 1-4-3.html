<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="./public/favicon.ico" />
    <meta http-equiv="cache-control" content="no-cache" />
    <title></title>
    <link rel="stylesheet" href=" https://necolas.github.io/normalize.css/8.0.1/normalize.css" />
    <link rel="stylesheet" href="./hightlight/default.min.css" />
    <link rel="stylesheet" href="./css/main.css" />
    <link rel="stylesheet" href="./css/copybutton.css" />
    <link rel="stylesheet" href="./css/hightlight.css" />
    <script src="./hightlight/hightlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BEVZJDBC7Z"></script>
    <script src="./js/gtag.js"></script>
  </head>

  <body>
    <header>
      <nav>
        <h1>
          <span id="toggle-menu"></span>
          <a href="index.html"></a>
        </h1>
      </nav>
    </header>
    <main>
      <aside>
        <nav></nav>
      </aside>
      <article>
        <h2 id="1-4-3">1-4-3 架構與效能: React & Vue3</h2>
        <h3>架構的效能到底指什麼</h3>
        <p>
          大部分應用的複雜度並不會對效能和產品體驗組成挑戰。現代化的架構憑藉高效的虛擬 DOM diff
          演算法、響應式理念及架構內部引擎,已經做得較為完美了,一般專案需求不會對效能產生太大的壓力。
        </p>
        <p>
          但是對於一些極其複雜的需求,效能最佳化問題是無法回避的。如果是圖形處理應用、DNA檢測實驗應用、豐富文字編輯或功能豐用的表單型應用,則很容易觸碰到效能瓶頸。同樣,作為架構的使用者,也需要對效能最佳化有所了解,這對了解架構本身也有很大的幫助。
        </p>
        <p>
          前端開發自然離不開瀏覽器,而效能最佳化大都在和瀏覽器進行處理,頁面每一幀的變化都是由瀏覽器繪製出來的,並且這個繪製額示器的更新頻率受限於顯示器的更新頻率,因此一個重要的效能資料指標是每秒
          60 幀的繪製頻率。這樣進行簡單的換算之後,每一幀只有 16.6ms 繪製時間。
        </p>
        <p>
          一個應用對使用者的互動回應處理過慢,則需要花費很長的時間來計算更新資料,這就會造成應用緩慢、效能不佳的問題,使得使用者體驗極差。對架構來說,以
          react 為例,開發者不需要額外關注 DOM 層面的操作,因為 React 透過維護虛擬 DOM 並使用其高效的
          diff 演算法,就可以決策出每次更新的最小化 DOM 合併操作。實際上,使用 React
          能做到的效能最佳化，使用純原生的 JavaScript 也能做到,甚至做得更好。只不過透過 React
          進行統一處理後,可以大幅節省開發成本,同時降低應用效能對開發者最佳化技能的依賴。
        </p>
        <p>
          因此,對於現代架構在效能方的最佳化,除了可以想辦法縮減本身的套件體積,主要在於架構本身執行時期對
          DOM操作的合理性及本身引擎計算的高效性等方面的最佳化。
        </p>
        <h3>React 的虛擬 DOM diff</h3>
        <p>React 主要透過以下幾種方式來確保虛擬 DOM diff 演算法更新都能夠高效。</p>
        <ul>
          <li>使用高效的 diff 演算法。</li>
          <li>進行 batch 操作。</li>
          <li>摒棄髒檢測更新方式。</li>
        </ul>
        <p>
          一個元件使用 setState 方法時， React
          都會認為該元件變「髒」了，進而觸發元件本身的重新繪製(re-render)時,因為 React
          始終維護兩套虛擬 DOM,其中一套是更新後的虛擬 DOM,另一套是前一個狀態的虛擬
          DOM，所以可以透過對這兩套虛擬 DOM 執行 diff
          演算法,找到需要變化的最小單元集，然後把這個最小單元集應用在真實的 DOM 中。
        </p>
        <p>
          透過 diff 演算法找到這個最小單元集後,React 採用啟發式的想法進行了一些假設,將兩棵 DOM
          樹之間的差異尋找成本由 O(n³) 縮減到 O(n)。
        </p>
        <p>說到這裡,你一定很想知道 React 進行了哪些大膽假設，下兩點便是。</p>
        <ul>
          <li>對 DOM 節點跨層級移動的情況忽略不計。</li>
          <li>
            擁有相同類型的兩個元件產生相似的樹狀結構,擁有不同類型的兩個元件產生不同的樹狀結構。
          </li>
        </ul>
        <p>根據這些假設, React 採取的策略如下。</p>
        <ul>
          <li>React 對元件樹進行分層比較,兩棵樹只會對同一層级的節進行比較。</li>
          <li>
            當對同一層級的節點進行比較時,對於不同的元件類型,直接將整個元件取代為更新後的元件。對於下圖所示的元件結構,如果子元件
            B 和 H 類型同時發生化,那麼當查到B 元件時,直接將其取代為元件可以減少不必要的資源消耗。
          </li>
        </ul>
        <ul>
          <li>
            當對同一層級的節進行比較時,對於相同的元件類型,如果元件的 state或props
            發生變化,直接重新繪製元件本身。開發者可以嘗試使用 shouldComponentUpdate
            生命週期函數來避開不必要的繪製。
          </li>
          <li>當對同一層級節點進行比較時,開發者可以使用 key 屬性來宣吿同一層級節點的更新方式。</li>
        </ul>
        <p>
          另外，setState 方法會引發「蝴蝶效應」,並透過創新的diff
          演算法找到需要更新的最小單元集,但是這些變更並不一定立即同步生效。實際上, React 會執行
          setState
          的合併操作,通俗地講就是「積攢歸併」一批變化後,再統一進行更新。顯然,這是出於對效能的考慮。
        </p>
        <h3>提升 React 應用效能的建議</h3>
        <p>React 繪製真實的 DOM 節點的過程由兩個主要過程組成。</p>
        <ul>
          <li>對 React 內部維的虛擬 DOM 進行更新。</li>
          <li>比較前後兩個虛擬 DOM,並將 diff 所得結果應用於真實的 DOM 中。</li>
        </ul>
        <p>這兩步極其關鍵。設想一下,如果虛擬 DOM ,那麼重新 繪製勢必會很耗時。</p>
        <h4>大幅地減少重新繪製</h4>
        <p>
          為了提升 React
          應用效能,首先想到的就是大幅地避開不必要的重新繪製。但是,當狀態發生變化時,重新繪製是 react
          內部的預設行為,如何確保不必要的繪製呢?
        </p>
        <p>
          最先想到的解決方案一定是使用 shouldComponentUpdate
          生命週期函數,它旨在比較前後狀態(state/props)是否出現了變更,根據是否變更來決定元件是否需要重新繪製。
        </p>
        <p>實際上,開發者可以透過很多方式給 react 送「不需要繪製」的訊號。</p>
        <p>
          舉例來說,對於無狀態元件傳回同一個 element 實例的情况,如果每次執行 render 方法都傳回相同的
          element 實例,React 會認為元件並沒有發生變化,程式如下所示。
        </p>
        <pre><code class="language-js">
class MyComponent extends Component {
  text = '';
  renderedElement = null;
  _render() {
    return &lt;div&gt;{this.props.text}&lt;/div&gt;
  }
  render() {
    if (!this.renderedElement || this.props.text !== this.text) {
      this.text = this.props.text;
      this.renderedElement = _render();
    }
    return this.renderedElement;
  }
  // ...
}
        </code></pre>
        <p>lodash 函式庫中的 memoize 該函數可以簡化上述程式,如下。</p>
        <pre><code class="language-js">
import memoize from 'lodash/memoize'
class MyComponent extends Component{
  _render = memoize((text) => &lt;div&gt;{text}&lt;/div&gt;)
  render() {
    return _render(this.props.text)
  }
}
        </code></pre>
        <p>不妨在之前介的高階元件的基礎上設想這樣一種高階元件:</p>
        <p>
          顆粒較細地控制元件的繪製行為。舉例來說,某個元件僅在某一項 props
          變化時才會觸發重新繪製。這樣一來,開發者就可以完全掌控元件繪製時機,更有針對性地進行繪製最佳化。
        </p>
        <p>
          在社群中,優秀的 recompose 函數庫剛好可以滿足需求。舉例來說,以下是利用了 recompose
          函數庫的onlyUpdateForKeys 修飾器的程式。
        </p>
        <pre><code class="language-js">
@onlyUpdateForKeys(['prop1', 'prop2'])
class MyComponent2 extends Component {
  render () {
    // ...
  }
}
        </code></pre>
        <p>
          在使用 onlyUpdateForKeys 修飾器的情況下, MyComponent2 元件只在 prop2
          發生變化時才進行繪製,其他 props 無論發生什麼變化,都不會觸發重新繪製。
        </p>
        <p>
          onlyUpdateForKeys 背後的原理是在高階元件中呼叫 shouldComponentUpdate
          方法,並在該方法中比較物件由完整的 props 轉為傳入的指定 props。可以翻閱 recompose
          源碼進行原理了解。
        </p>
        <h4>避開 inline function 反模式</h4>
        <p>
          需要注意一個「反模式」。當使用 render 方法時,要留意 render
          方法內建立的函數或陣列等,它們可能是顯性產生的,也可能是隱式產生的。這些新產生的函數或陣列在達到一定數量時會造成一定的效能負擔。同時
          render
          方法經常被反覆執行多次,也就是說總有新的函數或陣列被建立,這樣會造成記憶體無意義負擔。
        </p>
        <p>對效能比較人性化的做法通常是,只建立一次自訂函數,而非每次繪製時都建立一次,程式如下。</p>
        <pre><code class="language-js">
render() {
  return &lt;MyInput onChange={this.props.update.bind(this)} /&gt;;
}
        </code></pre>
        <p>或可以使用以下操作。</p>
        <pre><code class="language-js">
render() {
  return &lt;MyInput onChange={()=> this.props.update()} /&gt;;
}
        </code></pre>
        <p>
          對於在 render 方法內產生新的陣列或其他類類型資料的情况,也存在相似的問題,例如下面的程式。
        </p>
        <pre><code class="language-js">
render() {
  return &lt;SubComponent items={this.props.items || [] }/&gt;
}
        </code></pre>
        <p>這樣做會在每次繪製 this.props.items 不存在時建立一個空陣列。對此，更好的做法如下。</p>
        <pre><code class="language-js">
const EMPTY_ARRAY = []
render() {
  return &lt;SubComponent items={this.props.items || EMPTY_ARRAY}/&gt;
}
        </code></pre>
        <p>
          這些副作用對效能的影響都微乎其微,它們並不是效能最佳化的元兇。但是了解這些內容對於撰寫高品質的程式還是有幫助，後續會針對這種情況進行架構層面上的啟發式探索。
        </p>
        <h4>使用 PureComponent 確保開發性能</h4>
        <p>
          PureComponent 大致與 Component 相同,唯一不同的地方是 PureComponent
          會自動幫助開發者使用shouldComponentUpdate 生命週期方法，也就是說， 當元件 state 或 props
          發生化時,正常的 Component 都會自動進行重新繪製,在這種情況下 shouldComponentUpdate 會預傳回
          true。但是， Component 會先進行比較,即比較前後的 state 和 props
          是否相等。需要注意這種比較是淺比較。如何了解所謂的淺比較呢?以下是一段典型淺比較程式。
        </p>
        <pre><code class="language-js">
function shallowEqual (objA: mixed, objB: mixed) {
  if (is(objA, objB)) {
    return true;
  }

  if(typeof objA !== 'object' l1 objA === null || typeof objB !== 'object' II objB === null) {
    return false;
  }

  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);

  if(keysA.length !== keysB.length) {
    return false;
  }

  for (let i = 0; i < keysA.length; itt) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])){
      return false;
    }
  }
  return true;
}
        </code></pre>
        <p>基於以上程式,歸納出使用 PureComponent 時需要注意的細節,如下。</p>
        <ul>
          <li>
            既然是淺比較,也就是說在比較 props 和 state 時,如果比較物件是 Javascript
            基本類型,則會對其值是否相等進行判斷;如果比較物件是 JavaScript 參考類型,如 object 或
            array ，則會判斷其參考是否相同，而不會對值進行比較。
          </li>
          <li>開發者需要避免共用(mutate)帶來的問題。</li>
        </ul>
        <p>
          如果在一個父元件中對 object 進行了 mutate 操作,且子元件依賴此資料，並採用了 PureComponent
          宣告,那子元件將無法進行更新。儘管 props 中的某一項值
          發生了變化,但是由於它的參考並沒有發生變化,PureComponent 的 shouldComponentUpdate 會傳回
          false。更好的做法是在更新 props 或 state 時,傳回一個新的物件或陣列。
        </p>
        <h4>分析一個真實案例</h4>
        <p>
          設想一下,如果應用元件非常複雜,含有一個具有很長列表的元件,且只是其中一個子元件發生了變化,那麼使用
          PureComponent 進行比較,有選擇性地進行繪製,一定比對所有清單項目都重新繪製划算很多。
        </p>
        <p>
          看一個案例:簡單實現一個採用 PureComponent 和不採用 PureComponent
          的效能差別比較試驗。假如在頁面中需要繪製非常多的使用者資訊,所有的使用者資訊都被維護在一個
          user 陣列中,陣列的每一項為一個 JavaScript 物件,表示一個使用者的基本資訊,那麼可以使用 User
          元件繪製每一個使用者的資訊內容,範例如下。
        </p>
        <pre><code class="language-js">
import User from './User'
const Users = ({users}) =>&lt;div&gt;{Users.map(user => &lt;User {...user} /&gt;)}&lt;/div&gt;
        </code></pre>
        <p>
          這樣做存在的問題是 users 陣列作為 Users 元件的 props 如果 users 陣列的第K項發變化, users
          陣列便產生變化, Users 元件重新繪製會導致所有的 User 元件都進行繪製。對於某個 User
          元件,如果第K項並沒有發生變化,這個 User 元件就不需要重新繪製,但也不得不進行必要的繪製。
        </p>
        <p>在測試中,繪製了一個有 200 項資料的陣列,程式如下。</p>

        <pre><code class="language-js">
const arraySize = 200;
const getUsers = () =>
Array(arraySize)
.fill(1)
.map((_, index) => ({
  name: 'John Doe',
  hobby: 'Painting',
  age: index === 0 ? Math.random() * 100 : 50
}))
        </code></pre>
        <p>
          注意,這裡在 getUsers 方法中對 age 屬性進行了判斷,確保每次呼叫時， getUser
          傳回的陣列只有第一項的 age 屬性值不同,其餘的全部為50。在測試元件的componentDidUpdate
          中確保陣列將觸發 400 次重新繪製,並且每次只改變陣列的第一項 age
          屬性,其他的均保持不變,程式如下。
        </p>
        <pre><code class="language-js">
const repeats = 400;
componentDidUpdate (){
  ++this.renderCount;
  this.dt += performance.now() - this.startTime;
  if (this.renderCount  repeats === 0) {
    if (this.componentUnderTestIndex > -1) {
      this.dts[componentsToTest [this.componentUnderTestIndex]] = this.dt;
      console.log('dt',
      componentsToTest [this.componentUnderTest Index] ,
      this.dt);
    }
    ++this.componentUnderTestIndex;
    this.dt = 0;
    this.componentUnderTest= componentsToTest[this.componentUnderTestIndex];
  }
  if(this.componentUnderTest) {
    setTimeout(() => {
      this.startTime = performance.now();
      this.setState({ users: getUsers()})
    }, 0);
  } else {
    alert(`
      Bender Performance ArraySize: ${arraySize} Repeats: ${repeats}
      Functional: ${Math.round(this.dts.Functional)} ms
      pureComponent: ${Math.round(this.dts.PureComponent)} ms
      Component: ${Math.round(this.dts.Component)} ms
    `);
  }
}
        </code></pre>
        <p>下面對3種元件宣告方式進行比較。</p>
        <p>1.函數式方式,程式如下。</p>
        <pre><code class="language-js">
export const Functional = ({ name, age, hobby }) => (
  &lt;div&gt;
    &lt;span&gt;{name}&lt;/span&gt;
    &lt;span&gt;{age}&lt;/span&gt;
    &lt;span&gt;{hobby}&lt;/span&gt;
  &lt;/div&gt;
)
        </code></pre>
        <p>2.PureComponent 方式,程式如下。</p>
        <pre><code class="language-js">
export class PureComponent extends React. PureComponent {
  render() {
    const { name, age, hobby } = this.props;
    return (
      &lt;div&gt;
        &lt;span&gt;{name}&lt;/span&gt;
        &lt;span&gt;{age}&lt;/span&gt;
        &lt;span&gt;{hobby}&lt;/span&gt;
      &lt;/div&gt;
    )
  }
}
        </code></pre>
        <p>3.經典 class 方式,程式如下。</p>
        <pre><code class="language-js">
export class Component extends React.Component{
  render() {
    const { name, age, hobby } = this.props;
    return (
      &lt;div&gt;
        &lt;span&gt;{name}&lt;/span&gt;
        &lt;span&gt;{age}&lt;/span&gt;
        &lt;span&gt;{hobby}&lt;/span&gt;
      &lt;/div&gt;
    )
  }
}
        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
      </article>
    </main>
  </body>
  <script type="module" src="./js/main.js"></script>
</html>
