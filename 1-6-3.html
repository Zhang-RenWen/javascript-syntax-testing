<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="./public/favicon.ico" />
    <meta http-equiv="cache-control" content="no-cache" />
    <title></title>
    <link rel="stylesheet" href=" https://necolas.github.io/normalize.css/8.0.1/normalize.css" />
    <link rel="stylesheet" href="./hightlight/default.min.css" />
    <link rel="stylesheet" href="./css/main.css" />
    <link rel="stylesheet" href="./css/copybutton.css" />
    <link rel="stylesheet" href="./css/hightlight.css" />
    <script src="./hightlight/hightlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BEVZJDBC7Z"></script>
    <script src="./js/gtag.js"></script>
  </head>

  <body>
    <header>
      <nav>
        <h1>
          <span id="toggle-menu"></span>
          <a href="index.html"></a>
        </h1>
      </nav>
    </header>
    <main>
      <aside>
        <nav></nav>
      </aside>
      <article>
        <h2 id="1-6-3">1-6-3 React: 資料狀態管理<h2>
          <p>為什麼需要資料狀態管理，資料狀態管理到底在解決什麼樣的問題？這其實是架構、元件化帶來的概念。還是舉先前案例：在一個頁面上，點擊其中一處「訂閱」按鈕後，真面中的其他「訂閱」按鈕也會切換為「已訂閱」狀態。如果沒有資料狀態，也許就需要用以下方式來實現訂閱需求。</p>
        <h3 ></h3>
        <pre><code class="language-js">
const btnEle1 = $('#btn1')
const btnEle2 = $('#btn2')
btnEle1.on('click', () => {
  if(btnEle1.textContent ==='已訂閱'){
    return
  }
  btnEle1.textContent ='已訂閱'
  btnEle2.textContent ='已訂閱'
})
btnEle2.on('click', () => {
  if(btnEle2.textContent ==='已訂閱'){
    return
  }
  btnEle1.textContent ='已訂閱'
  btnEle2.textContent ='已訂閱'
})

        </code></pre>
        <p>這只是兩個按鈕的情況，處理起來就非常混亂了，而且難以維護，在這種情況下非常容易滋生 bug。</p>
        <p>現代化的架構解決這個問題的想法是元件化，元件依賴資料，對應這個場景的資料狀態的程式如下。</p>
        <pre><code class="language-js">
hasMarked: false / true
        </code></pre>
        <p>根據 hasMarked 這個狀態值，所有的訂閱元件都可以回應正確的視圖操作。把麵條式的程式轉換成可維護的程式後，對資料的管理就成了重中之重，這就是資料狀態的雛形。但是，一旦資料量越來越大，如何與元件形成良好的互動就是一種學問了。舉例來說，要考慮以下情況。</p>
        <ul>
          <li>一個元件需要和另一個元件共用狀態。</li>
          <li>一個元件需要改變另一個元件的狀態。</li>
        </ul>
        <p>以 React 為例，其他架構類似，如果 React 自己來維護這些資料，則資料狀態就是一個物件，並且這個物件在元件之間要互相修改，極其混亂。</p>
        <p>要考慮一個問題：hasMarked 這種資料到底是應該放在 state中維護，還是應該借助資料狀態管理類別庫，如 Redux，來維護呢？至少這樣一來，資料來源是單一的，資料狀態和元件是解耦的，也更加方便開發者進行偵錯和擴充資料。</p>
        <p>以 React 的state 和Redux為例，來分析一下「資料由誰來維護」的問題。</p>
        <p>React 的 state 是在元件內部維護的資料，當某項 state 需要與其他元件共用時，我們就可以透過 props 來完成元件間的通訊。從實作上來看，這就需要相對頂層的元件維護共用的 state 並提供修改此項 state 的方法。state 本身和修改方法都需要透過 props 傳遞給子孫元件。
        </p>
        <p>使用 Redux 的時候，在 Redux store 中維護資料。任何需要存取並更新資料的元件都需要連線 Redux，完成對 Redux store 的訂閱，這通常借助容器元件來完成。Redux 對資料採用集中管理的方式。</p>
        <p>從資料持久度、資料消費範圍的角度來回答這個問題。首先，在資料持久度上，不同狀態的資料大致可以分為以下3大類。</p>
        <ul>
          <li>快速變更型：這種資料在應用中代表了某些原子等級的資訊，且顯著特點是變更頻率最快。舉例來說，一個文字輸入框中的資料值可能會隨著使用者輸入在短時間內持續發生變化。這種資料顯然更適合在 React 元件內維護。</li>
          <li>中等持續型：在使用者瀏覽或使用應用時，這種資料常常會在頁面更新前保持穩定。舉例來說，從非同步請求介面透過 AJAX方式得來的資料，或使用者在個人中心頁編輯提交的資料。這種資料較為通用，也許會被不同元件所使用。資料在 Redux store 中維護，並透過 connect 方法和元件進行連接，是一種不錯的選擇。</li>
          <li>長遠穩定型：指在頁面多次更新或多次存取期間都保持不變的資料。因為
Redux store 會在每次真面掛載後都重新產生一份新的資料，因此這種類型的資料顯然應該儲存在Redux以外的地方，如伺服器端資料庫或瀏覽器的本機存放區。</li>
        </ul>
        <p>即資料消費範圍上來分析。資料特性表現在消費層面，即有多少元件需要使用。我們以此來區分 Rcact 和 Redux 的不同分工。
廣義上，需要消費同一種資料的元件越多，在 Redux store 中維護這種資料就越合理；反之，如果某種資料與其他資料隔離，只服務於應用中某單一部分，那麼由 React 維護更加合理。</p>
        <p>實際來看，共用的資料應該存在於 React 的高層元件中，由此在低層元件一層層傳遞。如果在 props 傳遞深度上只需要一兩個層級就能滿足消費資料的元件需求，那麼這樣的跨度是可以接受的；反之，如果跨越層級很多，那麼連結到的所有中間層級的元件就都需要進行接力賽式的傳遞，這樣顯然會增加很
          多乏味的傳遞程式，也破壞了中間元件的重複使用性。這時，使用Redlx維護共用狀態，合理設定容器元件，透過 comeet來打通資料，就是一種更好的方式。</p>
          <p>如果一些完全不存在父子關係的元件需要共用資料，舉例來說，前面提到過的真面需要在多處展示使用者圖示，那麼常常會造成資料輻射分散的問題，對於React 模式的狀態管理十分不利。在這種場景下，使用 Redux 同樣是更好的選擇。</p>
          <p>如果應用有追蹤狀態的功能，舉例來說，需要完成「重放」「返回」或 "Redo/Undo" 等需求，那麽使用 Redux 無疑是最佳選擇，因為 Redux 天生擅長於此：每一個 action 都描述了資料狀態的改變和更新，非常便於進行資料的集中管理。</p>
          <p>Redux 可以被任何一個資料管理類別庫所取代。</p>
          <h3>Redux使用方式</h3>
        <p>先上模板</p>
        <pre><code class="language-js">
<ShoppingApp>
  <Header />
  <SideMenu />
  <ProductsContainer>
  </ProductsContainer>
</ ShoppingApp>
        </code></pre>
        補圖
        <p>ProductsContainer 元件負責繪製每一個商品項目。</p>
        <pre><code class="language-js">
import Product from './Product'
export default class ProductsContainer extends Component {
   constructor (props) {
     super(props);
     this.state = {
       products: [
         '商品1',
         '商品2',
         '商品3'
       ]
     }
   }
   renderProducts () {
     return this.state.products.map((product) => {
       return <Product name={product｝ />
     })
   }
   render () {
     return (
       <div className='products-container'>
         {this.renderProducts()}
       </div>
     )
   }
}

        </code></pre>
        <p>Product 元件作為 UI 元件/展示元件，負責接收資料、展示資料。這樣一來，Product 元件即可用函數式/無狀態元件完成撰寫。</p>
        <pre><code class="language-js">
import React, { Component } from 'react'
export default class Product extends Component {
   render(){
     return (
       <div className='product'>
         {this.props.name}
       </div>
     )
   }
}
        </code></pre>
        <p>使用 React state 就可以實現上面的設計需求，且合理高效。</p>
        <p>但是，如果商品有「立即購買」按鈕，點擊「立即購買」後會將商品加入購物車（對應上面 Cart Info 部分），這時需要注意，購物車中的商品資訊會在多個頁面（如下所示）被消費。</p>
        <ul>
          <li>
            右上角需要展示購物車中商品數目的目前頁面
          </li>
          <li>
            購物車頁面本身
          </li>
          <li>
            支付前的確認頁面
          </li>
          <li>
            支付頁面
          </li>
        </ul>
        <p>這就是單頁面應用需要對資料狀態進行管理的訊號。我們可以維護一個cartList陣列以供應用消費，這個陣列放在 Redux 或 Vuex 中都是可行的。</p>
        <h4>合理的 connect 場景</h4>
        <p>在使用 Redux時，我們可以搭配 React-Redux 這個類別庫來聯通（connect）元件和資料，但是容易陷入的常見錯誤就是濫用 connect ，而沒有進行更合理的設計分析，或只在頂層進行 connect 設計，然後需要一層一層地進行資料傳遞。</p>
        <p>舉例來說，在一個頁面中存在 Profile、Feeds（資訊流）、Images（圖片）區域，如下圖</p>
        補圖
        <p>這些區域組成了頁面的主體，它們分別對應於 Profile、Feeds、Images 元件，共同作為 Page 元件的子元件而存在，對應的程式如下。</p>
        <pre><code class="language-js">
<Page>
  <Profile/>
  <Feeds/ >
  <Images/>
</Page>
        </code></pre>
        <p>如果只對 Page 這個頂層元件進行 connect 設計，其他元件的資料依靠 Page 元件進行分發，則設計如下圖所示</p>
        補圖
        <p>這樣做存在的問題如下</p>
        <ul>
          <li>當改動 Profile 元件中的使用者圖示時，由於資料變動，整個Page 元件都會被重新繪製。</li>
          <li>當刪除 Feeds 元件中的一筆資訊時，整個 Page 元件也都會被重新繪製。</li>
          <li>當在 Images 元件中增加一張圖片時，整個 Page元件同樣都會被重新繪製。</li>
        </ul>
        <p>因此，更好的做法是對 Profile、Feeds、Images 這3個元件分別進行 comneet
設計，在 connect 方法中使用 mapState ToProps 篩選出不同元件關心的 state部分，如圖</p>
補圖
<p>這樣做的好處很明顯，實際如下。</p>
<ul>
  <li>當改動 Profle 元件中的使用者圖示時，只有Profle 元件會被重新繪製。</li>
  <li>當刪除 Feeds 元件中的一筆資訊時，只有Feeds元件會被重新繪製。</li>
  <li>當在 Images 元件中增加一張圖片時，只有Images 元件會被重新繪製。</li>
</ul>
   <h4>扁平化資料狀態</h4>
   <p>扁平化的資料結構是一個很有意義的概念，它不僅能夠合理啟動開發邏輯，同時也是效能最佳化的一種表現。請看如下所示的資料結構。</p>
        <pre><code class="language-js">
{
  articles:[{
    comments: [{
      authors: [{
      }]
    }]
  }],
  // ...
}
        </code></pre>
        <p>這是一個文章列表加文章評論互動的場景，其對應於3個元件：Article、Comment 和Author。這樣的真面設計比比皆是，如下圖</p>
        補圖
        <p>按照上述資料結構，可以想像，reducer 函數的相關資料處理就很棘手了。如果 articles[2].comments[4].authors1 發生了變化，那麼想要傳回更新後的狀態，並確保不可變性，操作起來就沒有那麼簡單了，我們需要對深層物件結構進行拷貝或遞迴。</p>
        <p>因此，更好的資料結構設計一定是扁平化的，我們可以對 articles、comments、authors
進行扁平化處理，舉例來說，使 comments 陣列不再儲存 authors 資料，而是記錄 userId 評論內容中需要使用者資料時，只需在 users 陣列中按照 userId 進行分析即可。</p>
        <pre><code class="language-js">
{
  articles: [{
    // ...
  ]},
  comments: [{ 
    articleId:''
    userId: '',
  users: [{
      // ...
  }]
}
        </code></pre>
        <p>不同元件只需要關心不同的資料片段，舉例來說 Comment 元件只關心 comments 陳列 Author 元件只關心 users 陣列。這樣不僅操作更合理，而目能有效減少繪製壓力。</p>
        <h3>Redux 優缺點</h3>
        <pre><code class="language-js">
        </code></pre>
        <pre><code class="language-js">
        </code></pre>
        <pre><code class="language-js">
        </code></pre>
        <pre><code class="language-js">
        </code></pre>
        <pre><code class="language-js">
        </code></pre>
        <pre><code class="language-js">
        </code></pre>
        <pre><code class="language-js">
        </code></pre>
        
      </article>
    </main>
  </body>
  <script type="module" src="./js/main.js"></script>
</html>
