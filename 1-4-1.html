<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="./public/favicon.ico" />
    <meta http-equiv="cache-control" content="no-cache" />
    <title></title>
    <link rel="stylesheet" href=" https://necolas.github.io/normalize.css/8.0.//normalize.css" />
    <link rel="stylesheet" href="./hightlight/default.min.css" />
    <link rel="stylesheet" href="./css/main.css" />
    <link rel="stylesheet" href="./css/copybutton.css" />
    <link rel="stylesheet" href="./css/hightlight.css" />
    <script src="./hightlight/hightlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.///clipboard.min.js"></script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BEVZJDBC7Z"></script>
    <script src="./js/gtag.js"></script>
  </head>

  <body>
    <header>
      <nav>
        <h1>
          <span id="toggle-menu"></span>
          <a href="index.html"></a>
        </h1>
      </nav>
    </header>
    <main>
      <aside>
        <nav></nav>
      </aside>
      <article>
        <h2 id="1-4-1">1-4-1 效能監控和錯誤收集與上報</h2>
        <h3>效能監控指標</h3>
        <p>
          既然是效能監控，那麼首先就需要明確衡量指標。一般來說，業界認可的常用指撐有第一次繪製（FP）時間、第一次有內容繪製（FCP）時間、第一次有意義繪製（FMP）時間、初次載入畫面時間、使用者可互動（TTI）時間。接下來分別看一看每個指標的含義。
        </p>
        <ul>
          <li>
            <strong>第一次繪製時間(FP)：</strong>
            對於應用頁面，第一次出現視覺上不同於跳羅之前內容的時間點，或說是頁面發生第一次繪製的時間點。
          </li>
          <li>
            <strong>第一次有內容繪製時間(FCP)：</strong>
            指瀏覽器完成繪製 DOM
            中第一部分內容（可能是文字、影像或其他任何元素）的時間點，此時使用者應該在視覺上有直觀的感受。
          </li>
          <li>
            <strong>第一次有意義繪製時間(FMP)：</strong>
            指頁面關鍵元素的繪製時間。這個概念並沒有標準化定義，因為關鍵元素可以由開發者自行定義—究竟什麼是「有意義」的內容，只有開發者或產品經理自己了解。
          </li>
          <li>
            <strong>初次載入畫面時間(TTI)：</strong>
            對所有網頁應用，這是一個非常重要的指標。用白話來説，就是進入頁面之後，應用繪製完成整個手機螢幕（未捲動之前）內容的時間。需要注意的是，業界對這個指標其實沒有確切的定論，舉例來說，這個時間是否包含手機螢幕內圖片的繪製完成時間。
          </li>
          <li>
            <strong>使用者可互動時間：</strong>
            顧名思義，就是使用者可以與應用進行互動的時間。一般來講，我們認為是DOMReady
            的時間，因為我們通常會在這時綁定事件操作。如果頁面中有關互動的指令稿沒有下載完成，那麼當然沒有到達所謂的使用者可互動時間。那麼，如何定義
            DOMReady 時間呢？我推薦參考司徒正美的文章《何謂DOMReady》。
          </li>
        </ul>
        圖1
        <p>
          圖1是造訪 Medium 行動網站分析獲得的時序圖，可根據網頁載入的不同時段體會個時間節點變化。
        </p>
        圖2
        <p>Google Lighthouse 對網站的分析結果如 圖2 所示。</p>
        <p>
          請注意，First Meaningful Paint、First Contentful Paint 及 Time to
          Interactive（可互動時間）都包含在結果中。
        </p>
        <p>
          這裡先對這些時間節點及資料有一個初步的認識，後面將逐步學習如何統計這些時間，並做出如 圖2
          所示的分析系統。接下來，繼續了解兩個概念。
        </p>
        <ul>
          <li>
            <strong>總下載時間：</strong>
            頁面所有資源載入完成所需要的時間。一般可以統計 window.onload
            時間，這樣可以統計出同步載入的資源全部載入完的耗時。如果頁面中存在較多非同步繪製，那麼可以將非同步繪製全部完成的時間作為總下載時間。
          </li>
          <li>
            <strong>目訂指標：</strong>
            由於應用特點不同，所以可以根據需求自訂時間。舉例來說，一個類似 Instagram
            的頁面由圖片瀑布流組成，那麼可能非常關心螢幕中第一排圖片繪製完成的時間。
          </li>
        </ul>
        <p>
          這裡提一下，DOMContentLoaded 與 load
          事件的區別。其實從這兩個事件的命名中就能體會到，DOMContentLoaded 指的是文件中 DOM
          內容載入完畢的時間，也就是說 HTML
          結構已經是完整的了。但是，很多頁面都包含圖片、特珠字型、視訊、音訊等其他資源，由於這些資源由網路請求取得，需要額外的網路請求，因此
          DOM 內容載入完畢時，這些資源還沒有請求或繪製完成。當頁面上所有資源載入完成後，Load
          事件才會被觸發。因此，在時間除上，Load 事件常常會落後於 DOMContentLoaded 事件，如 圖3
          所示。
        </p>
        圖3
        <h3>FMP 的智慧獲取演算法</h3>
        <p>
          這裡結合自訂指標和第一次有意義繪製（FMP）時間，稍微延伸一點內容：
          由於第一次有意義繪製比較主觀，開發者可以自行指定究竟哪些屬於有意義
          的繪製元素，因此可以透過FMP的智慧獲取演算法來自訂FMP時間・該演 算法的實現過程如下。
        </p>
        <p>首先，取得有意義的繪製元素。一般認為，具備以下幾個條件的元素更像是有意義的元素。</p>
        <ul>
          <li>體積百分比比較大。</li>
          <li>螢幕內可見百分比大。</li>
          <li>屬於資源載入元素（img、svg、video、object、embed、canvas）。</li>
          <li>由具備以上特徵的多種元素共同組成的元素。</li>
        </ul>
        <p>根據元素對頁面視覺的貢獻對元素特點的權重進行劃分，實際權重值如下所示。</p>
        <pre><code class="language-js">
const weightMap = {
  SVG: 2,
  IMG: 2,
  CANVAS: 3,
  OBJECT: 3, 
  EMBED: 3,
  VIDEO: 3,
  OTHER: 1
}
        </code></pre>
        <p>
          接著，對整個頁面進行深度優先檢查搜尋，之後對每一個元素進行分數計算，實際透過
          element.getBoundingClientRect 取得元素的位置和大小，然後透過計算所有元素的「width * height
          * weight * 元素在 viewport
          中的面積百分比」的乘積，確定元素的最後得分。將該元素的子元素得分之和與其得分進行比較，取較大值，記錄在候選集合中。這個集合是可視區域內得分最高的元素的集合，對這個集合的得分取平均值，然後過濾出在平均分之上的元素集合，進行時間計算。這就獲得了一個智慧的
          FMP 時間。最後，程式由 qbright 實現。
        </p>
        <h3>效能資料取得</h3>
        <p>了解了上述效能指標，下面來分析一下這些效能指標的資料究竟該如何計算並取得。</p>
        <h4>window.performance：強大但有缺點</h4>
        <p>
          目前最為流行和可靠的方案是採用 window.performance API
          計算效能指標資料，該API非常強大，不僅能計算出與頁面效能相關的資料，還能計算出與頁面資源載入和非同步請求相關的資料。
          呼叫 window.performance timing 會傳回一個物件，這個物件包含各種頁面載入
          和繪製的時間節點，如圖4所示。
        </p>
        圖4
        <p>可以透過對上圖中的資訊進行計算獲得以下程式。</p>

        <pre><code class="language-js">
const window.performance = {
  memory: {
    usedJSHeapSize,
    totalJSHeapSize, 
    jsHeapSizeLimit
  },
  navigation: {
    // 透過頁面重新導向跳躍到目前頁面的次數
    redirectCount,
    // 以哪種方式進入頁面
    // 0 正常跳躍進入
    // 1 透過 window.location.reload() 重新更新進入
    // 2 透過瀏覽器歷史記錄及瀏覽器中的前進後退按鈕進入
    // 255 透過其他方式進入
    type,
  },
  timing: {
    // 等於前一個頁面的 unLoad 時間，如果沒有前一個頁面，則等於 fetchStart 時間 navigationStart
    // 前一個頁面的 unLoad 時間，如果沒有前一個頁面或前一個頁面與目前頁面在不同域中，則值為0
    unloadEventStart,
    // 前一個頁面中 unLoad 事件綁定的回呼函數執行完畢的時間
    unloadEventEnd, 
    redirectStart, 
    redirectEnd,
    // 檢查快取前，準備請求第一個資源的時間
    fetchStart,
    // 域名查詢開始的時間
    domainLookupStart,
    // 域名查詢結束的時間
    domainLookupEnd,
    // HTTP（TCP）開始建立連接的時間 connectStart，
    // HTTP （TCP）建立連接結束的時間
    connectEnd,
    secureConnectionStart，
    // 連接建立完成後，請求文件開始的時間 requestStart，
    // 連接建立完成後，文件開始傳回並收到內容的時間
    responseStart,
    // 最後一個位元組傳回並收到內容的時間
    responseEnd,
    // Document.readyState 值為 loading 的時間
    domLoading,
    // Document.readyState值為interactive的時間
    domInteractive,
    // DOMContentLoaded事件開始的時間
    domContentLoadedEventStart,
    // DOMContentLoaded事件結束的時間
    domContentLoadedEventEnd,
    // Document.readyState值為 complete 的時間
    domComplete,
    // load事件開始的時間
    loadEventStart,
    // load事件結束的時間
    loadEventEnd
  }
}
        </code></pre>
        <p>根據這些時間節點選擇對應的時間兩兩做差，便可以計算出一些典型指標，實際如下。</p>
        <pre><code class="language-js">
const calcTime = ()=> {
  let times = {}
  let t = window.performance.timing
  // 重新導向時間
  times.redirectTime = t.redirectEnd - t.redirectStart
  // DNS 查詢耗時
  times.dnsTime = t.domainLookupEnd - t.domainLookupStart
  // TCP 建立連接完成驗證的時間
  connect = t.connectEnd - t.connectStart
  // TTFB 讀取頁面第一個位元組的時間
  times. ttfbTime = t.responseStart - t.navigationStart
  // DNS 快取時間
  times.appcacheTime = t.domainLookupStart - t.fetchStart
  // 移除頁面的時間
  times.unloadTime = t.unloadEventEnd - t.unloadEventStart
  // TCP 連接耗時
  times.tcpTime = t.connectEnd - t.connectStart
  // request 請求耗時
  times.regTime = t.responseEnd - t.responseStart
  // 解析 DOM 樹耗時
  times.analysisTime = t.domComplete - t.domInteractive
  // 空閒時間
  times.blankTime = t.domLoading - t.fetchStart
  // domReadyTime 即使用者可互動時間
  times.domReadyTime = t.domContentLoadedEventEnd - t.fetchStart
  // 使用者等待頁面完全可用的時間
  times.loadPage = t.loadEventEnd - t.navigationStart
  return times
}
        </code></pre>
        <p>
          這個 API 的功能非常強大，但是並不適用於所有場景。舉例來說，如果在單頁應用中改變 URL
          但不更新頁面（單頁應用的典型路由方案），那麼使用 window.performance.timing
          所取得的資料是不會更新的還需要開發者重新設計統計方案。同時，window.performance.timing
          可能無法滿足一些自訂的資料。下面來分析一下部分無法直接取得的效能指標的計算方法。
        </p>
        <h4>自訂時間計算</h4>
        <p>
          初次載入畫面時間的計算方式不盡相同，開發者可以根據自己的需求來確定初次載入畫面時間的計算方式。下面列舉幾個典型的方案。
        </p>
        <p>
          對網頁高度小於螢幕的網站來說，統計初次載入畫面繪製耗時非常簡單，只要在頁面底部加上指令稿，記錄執行該指令稿的時間，並將這個時間與
          window.performance.timing.navigationStart 時間做差，即獲得初次載入畫面繪製耗時。
        </p>
        <p>
          但網頁高度小於螢幕的網站畢竟是少數，對網頁高度大於一頁的頁面來說，需要先估算出接近於一螢幕的最後一個元素的位置，然後在該位置插入下面的指令稿。
        </p>
        <pre><code class="language-js">
var time = +new Date() - window.performance. timing.navigationStart
        </code></pre>
        <p>上述方案顯然是比較理想化的，很難透過自動化工具或一段集中管理的程式對時間進行統計。</p>
        <p>
          開發者直接在頁面 DOM
          中插入時間統計，不僅使程式侵入性太強，而且花費的成本很高。同時，這樣的計算方式其實並沒有考慮初次載入畫面圖片載入的情況，也就是說對於初次載入畫面圖片未載人完的情況，會被認為載入已經完成。如果要考慮初次載入畫面圖片的載入。建議使用透過集中化指令稿統計初次載入畫面時間的方法：使用計時器不斷檢測
          img
          節點，判斷圖片是否在初次載入畫面且載入完成，找到初次載入畫面載入最慢的圖片載入完成的時間，進一步計算出初次載入畫面時間；如果初次載入畫面沒有圖片，那就使用
          DOMReady 時間。計算初次載入畫面繪製耗時的相關程式如下。
        </p>
        <pre><code class="language-js">
const win = window
const firstScreenHeight = win.screen.height
let firstScreenImgs = []
let isFindLastImg = false
let allImgLoaded = false
let collect = []
const t = setInterval(() => {
  let i, img 
  if (isFindLastImg) {
    if (firstScreenImgs.length){
      for (i = 0; i &lt; firstScreenImgs.length; i++) {
        img = firstScreenImgs[i]
        if (!ing.complete) {
          allImgLoaded = false
          break
        } else {
          allImgLoaded = true
        }
      }
    }else {
      allImgLoaded = true
    }
    if (allImgLoaded) {
      collect.push({
        firstScreenLoaded: startTime - Date.now()
      })
      clearInterval(t)
    }
  } else {
    var imgs = body.querySelector('img')
    for (i = 0;i &lt; imgs.length; i++){
      img = imgs[i]
      let imgOffsetTop = getOffsetTop(img)
      if (imgOffsetTop > firstScreenHeight) {
        isFindLastImg = true
        break
      } else if (imgOffsetTop &lt;= firstScreenHeight && ! img.hasPushed) {
        img.hasPushed = 1
        firstScreenImgs.push(img)
      }
    }
  }
},0)

const doc = document
doc.addEventListener('DOMcontentLoaded',()=>{
  const imgs = body.querySelector('img')
  if (!imgs.length) {
    isFindLastImg = true
  }
})

win.addEventListener('load',()=>{
  allImgLoaded = true
  isFindLastImg = true
  if (t) {
    clearInterval(t)
  }
})
        </code></pre>
        <p>
          另外一種方式是不使用計時器，且預設影響初次載入畫面時間的主要因素是圖片的載入，如果沒有圖片，那麼純粹繪製文字是很快的，因此，可以透過統計初次載入畫面內圖片的載入時間取得初次載入畫面繪製完成的時間，程式如下。
        </p>
        <pre><code class="language-js">
(function logFirstScreen () {
  let images = document.getElementsByTagName('img')
  let iLen = images.length
  let curMax = 0
  let inScreenLen = 0

  // 圖片的載入回呼
  function imageBack () {
    this.removeEventListener && this.removeEventListener('load',imageBack,!1)
    if (++curMax === inScreenLen) {
      // 所有在初次載入畫面的圖片均已載入完成的話，發送記錄檔
      log()
    }
  }
  //對所有位於指定區域的圖片綁定回呼事件
  for (var s = 0; s &lt; iLen;s++){
    var img = images[s]
    var offset = {
      top: 0
    }
    var curImg = img
    while(curImg.offsetParent) {
      offset.top += curImg.offsetTop
      curImg = curImg.offsetParent
    }
    // 判斷圖片在不在初次載入畫面
    if (document. documentElement. clientHeight &lt; offset.top) {
      continue
    }
    // 圖片還沒有載入完成的話
    if (!img.complete) {
      inScreenLent+
      img.addEventListener ('load', imageBack, !1)
    }
  }
  //如果初次載入畫面沒有圖片，則直接發送記錄檔
  if (inScreenLen ===0) {
    log()
  }
  // 對發送記錄檔進行統計
  function log () {
    window.loginfo.firstScreen = +new Date()- window.performance.timing.navigationStart
    console.log('初次載入畫面時間：'，+new Date()- window.performance.timing.navigationStart)
  }
})()
        </code></pre>
        <p>
          可見，除了可以使用教科書般強大的 Performance
          API，我們也完全擁有自主權來統計各種頁面效能資料。這需要開發者根據實際場景和業務需求，結合社區已有方案，找到完全適合自己的統計擷取方式。
        </p>
        <h3>錯誤訊息收集</h3>
        <p>
          錯誤訊息收集方式首先會想到兩種：透過ty catch 補捉錯誤，以及透過 window.onerror 進行監聽。
        </p>
        <h4>try catch 方案</h4>
        <p>先來看一下 try catch 方案，程式如下。</p>
        <pre><code class="language-js">
try{
  //程式區塊
} catch (e){
  //錯誤處理
  //這裡可以將錯誤訊息發送給伺服器端
}finally{
  // 額外處理
}
        </code></pre>
        <p>
          這種方式需要開發者對預估存在錯誤風險的程式進行包裹，這個套件包裹過程可以手動增加，也可以透過自動化工具或類別庫完成。自動化方案是
          AST 技術實現為基礎的，舉例來說，UglifyJS 透過提供操作 AST 的API，使得可以對每個函數增加
          try catch，社區上的 foio 實現就是一個很好的實例。為函數自動包裹 try catch 的實現程式如下。
        </p>
        <pre><code class="language-js">
const fs = require('fs')
const = require('lodash')
const UglifyJS = require('uglify-js')
const isASTFunctionNode = node => node instanceof UglifyJS.AST_Defun || node instanceof UglifyJS.AST _Function
const globalFuncTryCatch = (source, errorHandler) => {
  if (!_.isFunction(errorHandler)) {
    throw 'errorHandler should be a valid function'
  }
  const errorHandlerSource = errorHandler.toString()
  const errorHandlerAST = UglifyJS.parse('(' + errorHandlerSource + ')(error) ;')
  var tryCatchAST = UglifyJS.parse('try{}catch(error){}')
  const sourceAST = UglifyJS.parse(source)
  var topFuncScope = []
  tryCatchAST.body[0].catch.body[0] = errorHandlerAST
  const walker = new UglifyJS.TreeWalker(function(node){
    if(isASTFunctionNode(node)) {
      topFuncScope.push(node)
    }
  })
  sourceAST.walk(walker)
  sourceAST.transform(transfer)
  const transfer = new UglifyJS.TreeTransformer(null,
  node => {
    if (isASTFunctionNode(node) && _.includes(topFuncScope, node)) {
      var stream = UglifyJS.OutputStream()
      for (var i = 0; i &lt; node. body. length; i++) {
        node.body[i].print(stream)
      }
      var innerFuncCode = stream.toString()
      tryCatchAST.body[0].body.splice(0, tryCatchAST.body[0].body.length)
      var innerTyrCatchNode = UglifyJS.parse(innerFuncCode,{toplevel: tryCatchAST.body[0]})
      node,body.splice(0, node.body.length) 
      return UglifyJS.parse(innerTyrCatchNode.print_to_string(),{toplevel: node});
    }
  })
  const outputCode = sourceAST.print_to_string({beautify: true})
  return outputCode
}
module.exports.globalFuncTryCatch = globalFuncTryCatch
        </code></pre>
        <p>
          從 globalFuncTryCatch 函數的第一個參數中獲得目標程式 source，將其轉為 AST 的程式如下。
        </p>
        <pre><code class="language-js">
 const sourceAST = UglifyJS.parse(source)
        </code></pre>
        <p>
          globalFuncTryCatch
          函數的第二個參數為開發者定義的出現錯誤時的回應函數，將錯誤回應函數字字元字串化並轉為 AST
          插入 catch 區塊中，程式如下。
        </p>
        <pre><code class="language-js">
var tryCatchAST = UglifyJS.parse('try{}catch(error){}')
const errorHandlerSource = errorHandler.toString()
const errorHandlerAST = UglifyJS.parse('(' +errorHandlerSource+')(error);')
tryCatchAST.body[O].catch.body[0] = errorHandlerAST
        </code></pre>
        <p>
          這樣，借助於 globalFuncTryCatch 便可以對每個函數增加 try catch 敘述，並根據
          globalFuncTryCatch
          的第二個參數傳入自訂的錯誤處理函數（可以在該函數中進行錯誤上報），程式如下。
        </p>
        <pre><code class="language-js">
globalFuncTryCatch(inputCode, function(error) {
  // 此處是異常處理程式，可以上報並記錄記錄檔
})
        </code></pre>
        <p>這裡的關鍵在於要使用 UglifyJS 來對 AST 進行檢查，並在其中加入標記的內容，程式如下。</p>
        <pre><code class="language-js">
const walker = new UglifyJS.TreeWalker(function (node) {
  if (isASTFunctionNode(node)) {
    topFuncScope.push(node)
  }
})
sourceAST.walk(walker)
sourceAST.transform(transfer)
        </code></pre>
        <p>最後傳回經過處理後的程式，如下所示。</p>
        <pre><code class="language-js">
const outputCode = sourceAST.print_to_string({beautify: true})
return outputCode
        </code></pre>
        <p>使用 try catch 可以確保頁面不當機，並對錯誤進行完整處理，這是一個非常好的習慣。</p>
        <h4>try catch 方案的限制</h4>
        <p>
          try catch
          處理異常的能力有限，對於處理執行時期同步錯誤是沒有問題的。但卻無法處理語法錯誤和非同步錯誤。下面來看一個處理執行時期同步錯誤的範例，程式如下。
        </p>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
        <pre><code class="language-js">

        </code></pre>
      </article>
    </main>
  </body>
  <script type="module" src="./js/main.js"></script>
</html>
